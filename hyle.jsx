// Generated by CoffeeScript 1.10.0// Generated by CoffeeScript 1.10.0var Hyle;Hyle = (function() {  function Hyle() {}  Hyle.prototype.initialize = function() {    this.name = "Hyle";    this.mail = "s.lavoie.b@gmail.com";    this.version = "1.3.0";    this.parser = new Hyle.Parser;    this.composer = new Hyle.Composer;    this["debugger"] = new Hyle.Debugger;    this.api = new Hyle.Api;    if (this.debug) {      this.selfBuild("/Applications/Adobe After Effects CC 2014/Scripts/Startup");    }    if (this.debug) {      this.selfBuild((new File($.fileName)).parent.parent.path);    }    return this["debugger"].initialize();  };  Hyle.prototype.selfBuild = function(path) {    var currentPath;    currentPath = (new File($.fileName)).parent.parent.path;    return esy.file.buildExtendScript(currentPath + "/lib/hyle.js", [path + "/hyle.jsx"]);  };  Hyle.prototype.parse = function(data) {    app.beginUndoGroup('Hyle');    this.parser.parse(data);    return app.endUndoGroup();  };  Hyle.prototype.compose = function() {    app.beginUndoGroup('Hyle');    this.composer.compose();    return app.endUndoGroup();  };  return Hyle;})();var hyle;hyle = new Hyle();$.debug = hyle.debug = false;/*Copyright (c) 2010 Jeremy FaivrePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software is furnishedto do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.*/(function(){/** * Exception class thrown when an error occurs during parsing. * * @author Fabien Potencier <fabien@symfony.com> * * @api *//** * Constructor. * * @param string  message The error message * @param integer   parsedLine The line where the error occurred * @param integer   snippet The snippet of code near the problem * @param string  parsedFile The file name where the error occurred */var YamlParseException = function(message, parsedLine, snippet, parsedFile){    this.rawMessage = message;    this.parsedLine = (parsedLine !== undefined) ? parsedLine : -1;    this.snippet = (snippet !== undefined) ? snippet : null;    this.parsedFile = (parsedFile !== undefined) ? parsedFile : null;    this.updateRepr();    this.message = message;};YamlParseException.prototype ={  name: 'YamlParseException',  message: null,  parsedFile: null,  parsedLine: -1,  snippet: null,  rawMessage: null,  isDefined: function(input)  {    return input != undefined && input != null;  },  /**  * Gets the snippet of code near the error.  *  * @return string The snippet of code  */  getSnippet: function()  {    return this.snippet;  },  /**  * Sets the snippet of code near the error.  *  * @param string snippet The code snippet  */  setSnippet: function(snippet)  {    this.snippet = snippet;    this.updateRepr();  },  /**  * Gets the filename where the error occurred.  *  * This method returns null if a string is parsed.  *  * @return string The filename  */  getParsedFile: function()  {    return this.parsedFile;  },  /**  * Sets the filename where the error occurred.  *  * @param string parsedFile The filename  */  setParsedFile: function(parsedFile)  {    this.parsedFile = parsedFile;    this.updateRepr();  },  /**  * Gets the line where the error occurred.  *  * @return integer The file line  */  getParsedLine: function()  {    return this.parsedLine;  },  /**  * Sets the line where the error occurred.  *  * @param integer parsedLine The file line  */  setParsedLine: function(parsedLine)  {    this.parsedLine = parsedLine;    this.updateRepr();  },  updateRepr: function()  {    this.message = this.rawMessage;    var dot = false;    if ('.' === this.message.charAt(this.message.length - 1)) {      this.message = this.message.substring(0, this.message.length - 1);      dot = true;    }    if (null !== this.parsedFile) {      this.message += ' in ' + JSON.stringify(this.parsedFile);    }    if (this.parsedLine >= 0) {      this.message += ' at line ' + this.parsedLine;    }    if (this.snippet) {      this.message += ' (near "' + this.snippet + '")';    }    if (dot) {      this.message += '.';    }  }}/** * Yaml offers convenience methods to parse and dump YAML. * * @author Fabien Potencier <fabien@symfony.com> * * @api */var YamlRunningUnderNode = false;var Yaml = function(){};Yaml.prototype ={  /**   * Parses YAML into a JS representation.   *   * The parse method, when supplied with a YAML stream (file),   * will do its best to convert YAML in a file into a JS representation.   *   *  Usage:   *  <code>   *   obj = yaml.parseFile('config.yml');   *  </code>   *   * @param string input Path of YAML file   *   * @return array The YAML converted to a JS representation   *   * @throws YamlParseException If the YAML is not valid   */  parseFile: function(file /* String */, callback /* Function */)  {    if ( callback == null )    {      var input = this.getFileContents(file);      var ret = null;      try      {        ret = this.parse(input);      }      catch ( e )      {        if ( e instanceof YamlParseException ) {          e.setParsedFile(file);        }        throw e;      }      return ret;    }    this.getFileContents(file, function(data)    {      callback(new Yaml().parse(data));    });  },  /**   * Parses YAML into a JS representation.   *   * The parse method, when supplied with a YAML stream (string),   * will do its best to convert YAML into a JS representation.   *   *  Usage:   *  <code>   *   obj = yaml.parse(...);   *  </code>   *   * @param string input string containing YAML   *   * @return array The YAML converted to a JS representation   *   * @throws YamlParseException If the YAML is not valid   */  parse: function(input /* String */)  {    var yaml = new YamlParser();    return yaml.parse(input);  },  /**   * Dumps a JS representation to a YAML string.   *   * The dump method, when supplied with an array, will do its best   * to convert the array into friendly YAML.   *   * @param array  array JS representation   * @param integer inline The level where you switch to inline YAML   *   * @return string A YAML string representing the original JS representation    *    * @api    */  dump: function(array, inline, spaces)  {    if ( inline == null ) inline = 2;    var yaml = new YamlDumper();    if (spaces) {        yaml.numSpacesForIndentation = spaces;    }    return yaml.dump(array, inline);  },  getXHR: function()  {    if ( window.XMLHttpRequest )      return new XMLHttpRequest();    if ( window.ActiveXObject )    {      var names = [      "Msxml2.XMLHTTP.6.0",      "Msxml2.XMLHTTP.3.0",      "Msxml2.XMLHTTP",      "Microsoft.XMLHTTP"      ];      for ( var i = 0; i < 4; i++ )      {        try{ return new ActiveXObject(names[i]); }        catch(e){}      }    }    return null;  },  getFileContents: function(file, callback)  {      if ( YamlRunningUnderNode )      {          var fs = require('fs');          if ( callback == null )          {              var data = fs.readFileSync(file);              if (data == null) return null;              return ''+data;          }          else          {              fs.readFile(file, function(err, data)              {                  if (err)                      callback(null);                  else                      callback(data);              });          }      }      else      {        var request = this.getXHR();        // Sync        if ( callback == null )        {          request.open('GET', file, false);          request.send(null);          if ( request.status == 200 || request.status == 0 )            return request.responseText;          return null;        }        // Async        request.onreadystatechange = function()        {          if ( request.readyState == 4 )            if ( request.status == 200 || request.status == 0 )              callback(request.responseText);            else              callback(null);        };        request.open('GET', file, true);        request.send(null);      }  }};var YAML ={  /*   * @param integer inline The level where you switch to inline YAML   */  stringify: function(input, inline, spaces)  {    return new Yaml().dump(input, inline, spaces);  },  parse: function(input)  {    return new Yaml().parse(input);  },  load: function(file, callback)  {    return new Yaml().parseFile(file, callback);  }};// Handle node.js caseif (typeof exports !== 'undefined') {    if (typeof module !== 'undefined' && module.exports) {        exports = module.exports = YAML;        YamlRunningUnderNode = true;        // Add require handler        (function () {            var require_handler = function (module, filename) {                // fill in result                module.exports = YAML.load(filename);            };            // register require extensions only if we're on node.js            // hack for browserify            if ( undefined !== require.extensions ) {                require.extensions['.yml'] = require_handler;                require.extensions['.yaml'] = require_handler;            }        }());    }}// Handle browser caseif ( typeof(window) != "undefined" ){    window.YAML = YAML;}/** * YamlInline implements a YAML parser/dumper for the YAML inline syntax. */var YamlInline = function(){};YamlInline.prototype ={  i: null,  /**   * Convert a YAML string to a JS object.   *   * @param string value A YAML string   *   * @return object A JS object representing the YAML string   */  parse: function(value)  {    var result = null;    value = this.trim(value);    if ( 0 == value.length )    {      return '';    }    switch ( value.charAt(0) )    {      case '[':        result = this.parseSequence(value);        break;      case '{':        result = this.parseMapping(value);        break;      default:        result = this.parseScalar(value);    }    // some comment can end the scalar    if ( value.substr(this.i+1).replace(/^\s*#.*$/, '') != '' ) {        esy.log("oups "+value.substr(this.i+1));      throw new YamlParseException('Unexpected characters near "'+value.substr(this.i)+'".');    }    return result;  },  /**   * Dumps a given JS variable to a YAML string.   *   * @param mixed value The JS variable to convert   *   * @return string The YAML string representing the JS object   */  dump: function(value)  {    if ( undefined == value || null == value )      return 'null';    if ( value instanceof Date)      return value.toISOString();    if ( typeof(value) == 'object')      return this.dumpObject(value);    if ( typeof(value) == 'boolean' )      return value ? 'true' : 'false';    if ( /^\d+$/.test(value) )      return typeof(value) == 'string' ? "'"+value+"'" : parseInt(value);    if ( this.isNumeric(value) )      return typeof(value) == 'string' ? "'"+value+"'" : parseFloat(value);    if ( typeof(value) == 'number' )      return value == Infinity ? '.Inf' : ( value == -Infinity ? '-.Inf' : ( isNaN(value) ? '.NAN' : value ) );    var yaml = new YamlEscaper();    if ( yaml.requiresDoubleQuoting(value) )      return yaml.escapeWithDoubleQuotes(value);    if ( yaml.requiresSingleQuoting(value) )      return yaml.escapeWithSingleQuotes(value);    if ( '' == value )      return "";    if ( this.getTimestampRegex().test(value) )      return "'"+value+"'";    if ( this.inArray(value.toLowerCase(), ['null','~','true','false']) )      return "'"+value+"'";    // default      return value;  },  /**   * Dumps a JS object to a YAML string.   *   * @param object value The JS array to dump   *   * @return string The YAML string representing the JS object   */  dumpObject: function(value)  {    var keys = this.getKeys(value);    var output = null;    var i;    var len = keys.length;    // array    if ( value instanceof Array )      /*( 1 == len && '0' == keys[0] )      ||      ( len > 1 && this.reduceArray(keys, function(v,w){return Math.floor(v+w);}, 0) == len * (len - 1) / 2) )*/    {      output = [];      for ( i = 0; i < len; i++ )      {        output.push(this.dump(value[keys[i]]));      }      return '['+output.join(', ')+']';    }    // mapping    output = [];    for ( i = 0; i < len; i++ )    {      output.push(this.dump(keys[i])+': '+this.dump(value[keys[i]]));    }    return '{ '+output.join(', ')+' }';  },  /**   * Parses a scalar to a YAML string.   *   * @param scalar scalar   * @param string delimiters   * @param object stringDelimiters   * @param integer i   * @param boolean evaluate   *   * @return string A YAML string   *   * @throws YamlParseException When malformed inline YAML string is parsed   */  parseScalar: function(scalar, delimiters, stringDelimiters, i, evaluate)  {    if ( delimiters == undefined ) delimiters = null;    if ( stringDelimiters == undefined ) stringDelimiters = ['"', "'"];    if ( i == undefined ) i = 0;    if ( evaluate == undefined ) evaluate = true;    var output = null;    var pos = null;    var matches = null;    if ( this.inArray(scalar[i], stringDelimiters) )    {      // quoted scalar      output = this.parseQuotedScalar(scalar, i);      i = this.i;      if (null !== delimiters) {        var tmp = scalar.substr(i).replace(/^\s+/, '');        if (!this.inArray(tmp.charAt(0), delimiters)) {          throw new YamlParseException('Unexpected characters ('+scalar.substr(i)+').');        }      }    }    else    {      // "normal" string      if ( !delimiters )      {        output = (scalar+'').substring(i);        i += output.length;        // remove comments        pos = output.indexOf(' #');        if ( pos != -1 )        {          output = output.substr(0, pos).replace(/\s+$/g,'');        }      }      else if ( matches = new RegExp('^(.+?)('+delimiters.join('|')+')').exec((scalar+'').substring(i)) )      {        output = matches[1];        i += output.length;      }      else      {        throw new YamlParseException('Malformed inline YAML string ('+scalar+').');      }      output = evaluate ? this.evaluateScalar(output) : output;    }    this.i = i;    return output;  },  /**   * Parses a quoted scalar to YAML.   *   * @param string  scalar   * @param integer i   *   * @return string A YAML string   *   * @throws YamlParseException When malformed inline YAML string is parsed   */  parseQuotedScalar: function(scalar, i)  {    var matches = null;    //var item = /^(.*?)['"]\s*(?:[,:]|[}\]]\s*,)/.exec((scalar+'').substring(i))[1];    if ( !(matches = new RegExp('^'+YamlInline.REGEX_QUOTED_STRING).exec((scalar+'').substring(i))) )    {      throw new YamlParseException('Malformed inline YAML string ('+(scalar+'').substring(i)+').');    }    var output = matches[0].substr(1, matches[0].length - 2);    var unescaper = new YamlUnescaper();    if ( '"' == (scalar+'').charAt(i) )    {      output = unescaper.unescapeDoubleQuotedString(output);    }    else    {      output = unescaper.unescapeSingleQuotedString(output);    }    i += matches[0].length;    this.i = i;    return output;  },  /**   * Parses a sequence to a YAML string.   *   * @param string sequence   * @param integer i   *   * @return string A YAML string   *   * @throws YamlParseException When malformed inline YAML string is parsed   */  parseSequence: function(sequence, i)  {    if ( i == undefined ) i = 0;    var output = [];    var len = sequence.length;    i += 1;    // [foo, bar, ...]    while ( i < len )    {      switch ( sequence.charAt(i) )      {        case '[':          // nested sequence          output.push(this.parseSequence(sequence, i));          i = this.i;          break;        case '{':          // nested mapping          output.push(this.parseMapping(sequence, i));          i = this.i;          break;        case ']':          this.i = i;          return output;        case ',':        case ' ':          break;        default:          var isQuoted = this.inArray(sequence.charAt(i), ['"', "'"]);          var value = this.parseScalar(sequence, [',', ']'], ['"', "'"], i);          i = this.i;          if ( !isQuoted && (value+'').indexOf(': ') != -1 )          {            // embedded mapping?            try            {              value = this.parseMapping('{'+value+'}');            }            catch ( e )            {              if ( !(e instanceof YamlParseException ) ) throw e;              // no, it's not            }          }          output.push(value);          i--;      }      i++;    }    throw new YamlParseException('Malformed inline YAML string "'+sequence+'"');  },  /**   * Parses a mapping to a YAML string.   *   * @param string mapping   * @param integer i   *   * @return string A YAML string   *   * @throws YamlParseException When malformed inline YAML string is parsed   */  parseMapping: function(mapping, i)  {    if ( i == undefined ) i = 0;    var output = {};    var len = mapping.length;    i += 1;    var done = false;    var doContinue = false;    // {foo: bar, bar:foo, ...}    while ( i < len )    {      doContinue = false;      switch ( mapping.charAt(i) )      {        case ' ':        case ',':          i++;          doContinue = true;          break;        case '}':          this.i = i;          return output;      }      if ( doContinue ) continue;      // key      var key = this.parseScalar(mapping, [':', ' '], ['"', "'"], i, false);      i = this.i;      // value      done = false;      while ( i < len )      {        switch ( mapping.charAt(i) )        {          case '[':            // nested sequence            output[key] = this.parseSequence(mapping, i);            i = this.i;            done = true;            break;          case '{':            // nested mapping            output[key] = this.parseMapping(mapping, i);            i = this.i;            done = true;            break;          case ':':          case ' ':            break;          default:            output[key] = this.parseScalar(mapping, [',', '}'], ['"', "'"], i);            i = this.i;            done = true;            i--;        }        ++i;        if ( done )        {          doContinue = true;          break;        }      }      if ( doContinue ) continue;    }    throw new YamlParseException('Malformed inline YAML string "'+mapping+'"');  },  /**   * Evaluates scalars and replaces magic values.   *   * @param string scalar   *   * @return string A YAML string   */  evaluateScalar: function(scalar)  {    scalar = this.trim(scalar);    var raw = null;    var cast = null;    if (  ( 'null' == scalar.toLowerCase() ) ||        ( '' == scalar ) ||        ( '~' == scalar ) )      return null;    if ( (scalar+'').indexOf('!str ') == 0 )      return (''+scalar).substring(5);    if ( (scalar+'').indexOf('! ') == 0 )      return parseInt(this.parseScalar((scalar+'').substr(2)));    if ( /^\d+$/.test(scalar) )    {      raw = scalar;      cast = parseInt(scalar);      return '0' == scalar.charAt(0) ? this.octdec(scalar) : (( ''+raw == ''+cast ) ? cast : raw);    }    if ( 'true' == (scalar+'').toLowerCase() )      return true;    if ( 'false' == (scalar+'').toLowerCase() )      return false;    if ( this.isNumeric(scalar) )      return '0x' == (scalar+'').substr(0, 2) ? this.hexdec(scalar) : parseFloat(scalar);    if ( scalar.toLowerCase() == '.inf' )      return Infinity;    if ( scalar.toLowerCase() == '.nan' )      return NaN;    if ( scalar.toLowerCase() == '-.inf' )      return -Infinity;    if ( /^(-|\+)?[0-9,]+(\.[0-9]+)?$/.test(scalar) )      return parseFloat(scalar.split(',').join(''));    if ( this.getTimestampRegex().test(scalar) )      return new Date(this.strtotime(scalar));    //else      return ''+scalar;  },  /**   * Gets a regex that matches an unix timestamp   *   * @return string The regular expression   */  getTimestampRegex: function()  {    return new RegExp('^'+    '([0-9][0-9][0-9][0-9])'+    '-([0-9][0-9]?)'+    '-([0-9][0-9]?)'+    '(?:(?:[Tt]|[ \t]+)'+    '([0-9][0-9]?)'+    ':([0-9][0-9])'+    ':([0-9][0-9])'+    '(?:\.([0-9]*))?'+    '(?:[ \t]*(Z|([-+])([0-9][0-9]?)'+    '(?::([0-9][0-9]))?))?)?'+    '$','gi');  },  trim: function(str /* String */)  {    return (str+'').replace(/^\s+/,'').replace(/\s+$/,'');  },  isNumeric: function(input)  {    try {      return (input - 0) == input && input.length > 0 && input.replace(/\s+/g,'') != '';    } catch (e) {    }  },  inArray: function(key, tab)  {    var i;    var len = tab.length;    for ( i = 0; i < len; i++ )    {      if ( key == tab[i] ) return true;    }    return false;  },  getKeys: function(tab)  {    var ret = [];    for ( var name in tab )    {      if ( tab.hasOwnProperty(name) )      {        ret.push(name);      }    }    return ret;  },  /*reduceArray: function(tab, fun)  {    var len = tab.length;    if (typeof fun != "function")      throw new YamlParseException("fun is not a function");    // no value to return if no initial value and an empty array    if (len == 0 && arguments.length == 1)      throw new YamlParseException("empty array");    var i = 0;    if (arguments.length >= 2)    {      var rv = arguments[1];    }    else    {      do      {        if (i in tab)        {          rv = tab[i++];          break;        }        // if array contains no values, no initial value to return        if (++i >= len)          throw new YamlParseException("no initial value to return");      }      while (true);    }    for (; i < len; i++)    {      if (i in tab)        rv = fun.call(null, rv, tab[i], i, tab);    }    return rv;  },*/  octdec: function(input)  {      return parseInt((input+'').replace(/[^0-7]/gi, ''), 8);  },  hexdec: function(input)  {    input = this.trim(input);    if ( (input+'').substr(0, 2) == '0x' ) input = (input+'').substring(2);      return parseInt((input+'').replace(/[^a-f0-9]/gi, ''), 16);  },  /**   * @see http://phpjs.org/functions/strtotime   * @note we need timestamp with msecs so /1000 removed   * @note original contained binary | 0 (wtf?!) everywhere, which messes everything up   */  strtotime: function (h,b){var f,c,g,k,d="";h=(h+"").replace(/\s{2,}|^\s|\s$/g," ").replace(/[\t\r\n]/g,"");if(h==="now"){return b===null||isNaN(b)?new Date().getTime()||0:b||0}else{if(!isNaN(d=Date.parse(h))){return d||0}else{if(b){b=new Date(b)}else{b=new Date()}}}h=h.toLowerCase();var e={day:{sun:0,mon:1,tue:2,wed:3,thu:4,fri:5,sat:6},mon:["jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec"]};var a=function(i){var o=(i[2]&&i[2]==="ago");var n=(n=i[0]==="last"?-1:1)*(o?-1:1);switch(i[0]){case"last":case"next":switch(i[1].substring(0,3)){case"yea":b.setFullYear(b.getFullYear()+n);break;case"wee":b.setDate(b.getDate()+(n*7));break;case"day":b.setDate(b.getDate()+n);break;case"hou":b.setHours(b.getHours()+n);break;case"min":b.setMinutes(b.getMinutes()+n);break;case"sec":b.setSeconds(b.getSeconds()+n);break;case"mon":if(i[1]==="month"){b.setMonth(b.getMonth()+n);break}default:var l=e.day[i[1].substring(0,3)];if(typeof l!=="undefined"){var p=l-b.getDay();if(p===0){p=7*n}else{if(p>0){if(i[0]==="last"){p-=7}}else{if(i[0]==="next"){p+=7}}}b.setDate(b.getDate()+p);b.setHours(0,0,0,0)}}break;default:if(/\d+/.test(i[0])){n*=parseInt(i[0],10);switch(i[1].substring(0,3)){case"yea":b.setFullYear(b.getFullYear()+n);break;case"mon":b.setMonth(b.getMonth()+n);break;case"wee":b.setDate(b.getDate()+(n*7));break;case"day":b.setDate(b.getDate()+n);break;case"hou":b.setHours(b.getHours()+n);break;case"min":b.setMinutes(b.getMinutes()+n);break;case"sec":b.setSeconds(b.getSeconds()+n);break}}else{return false}break}return true};g=h.match(/^(\d{2,4}-\d{2}-\d{2})(?:\s(\d{1,2}:\d{2}(:\d{2})?)?(?:\.(\d+))?)?$/);if(g!==null){if(!g[2]){g[2]="00:00:00"}else{if(!g[3]){g[2]+=":00"}}k=g[1].split(/-/g);k[1]=e.mon[k[1]-1]||k[1];k[0]=+k[0];k[0]=(k[0]>=0&&k[0]<=69)?"20"+(k[0]<10?"0"+k[0]:k[0]+""):(k[0]>=70&&k[0]<=99)?"19"+k[0]:k[0]+"";return parseInt(this.strtotime(k[2]+" "+k[1]+" "+k[0]+" "+g[2])+(g[4]?g[4]:""),10)}var j="([+-]?\\d+\\s(years?|months?|weeks?|days?|hours?|min|minutes?|sec|seconds?|sun\\.?|sunday|mon\\.?|monday|tue\\.?|tuesday|wed\\.?|wednesday|thu\\.?|thursday|fri\\.?|friday|sat\\.?|saturday)|(last|next)\\s(years?|months?|weeks?|days?|hours?|min|minutes?|sec|seconds?|sun\\.?|sunday|mon\\.?|monday|tue\\.?|tuesday|wed\\.?|wednesday|thu\\.?|thursday|fri\\.?|friday|sat\\.?|saturday))(\\sago)?";g=h.match(new RegExp(j,"gi"));if(g===null){return false}for(f=0,c=g.length;f<c;f++){if(!a(g[f].split(" "))){return false}}return b.getTime()||0}};/* * @note uses only non-capturing sub-patterns (unlike PHP original) */YamlInline.REGEX_QUOTED_STRING = '(?:"(?:[^"\\\\]*(?:\\\\.[^"\\\\]*)*)"|\'(?:[^\']*(?:\'\'[^\']*)*)\')';/** * YamlParser parses YAML strings to convert them to JS objects * (port of Yaml Symfony Component) */var YamlParser = function(offset /* Integer */){    this.offset = (offset !== undefined) ? offset : 0;};YamlParser.prototype ={  offset: 0,  lines: [],  currentLineNb: -1,  currentLine: '',  refs: {},  /**   * Parses a YAML string to a JS value.   *   * @param String value A YAML string   *   * @return mixed A JS value   */  parse: function(value /* String */)  {    this.currentLineNb = -1;    this.currentLine = '';    this.lines = this.cleanup(value).split("\n");    var data = null;      var context = null;    while ( this.moveToNextLine() )    {      if ( this.isCurrentLineEmpty() )      {        continue;      }      // tab?      if ( this.currentLine.charAt(0) == '\t' )      {        throw new YamlParseException('A YAML file cannot contain tabs as indentation.', this.getRealCurrentLineNb() + 1, this.currentLine);      }      var isRef = false;      var isInPlace = false;      var isProcessed = false;      var values = null;      var matches = null;      var c = null;      var parser = null;      var block = null;      var key = null;      var parsed = null;      var len = null;      var reverse = null;      if ( values = /^\-((\s+)(.+?))?\s*$/.exec(this.currentLine) )      {        if (context && 'mapping' == context) {          throw new YamlParseException('You cannot define a sequence item when in a mapping', this.getRealCurrentLineNb() + 1, this.currentLine);        }        context = 'sequence';        if ( !this.isDefined(data) ) data = [];        //if ( !(data instanceof Array) ) throw new YamlParseException("Non array entry", this.getRealCurrentLineNb() + 1, this.currentLine);        values = {leadspaces: values[2], value: values[3]};        if ( this.isDefined(values.value) && ( matches = /^&([^ ]+) *(.*)/.exec(values.value) ) )        {          matches = {ref: matches[1], value: matches[2]};          isRef = matches.ref;          values.value = matches.value;        }        // array        if ( !this.isDefined(values.value) || '' == this.trim(values.value) || values.value.replace(/^ +/,'').charAt(0) == '#' )        {          c = this.getRealCurrentLineNb() + 1;          parser = new YamlParser(c);          parser.refs = this.refs;          data.push(parser.parse(this.getNextEmbedBlock()));          this.refs = parser.refs;        }        else        {          if ( this.isDefined(values.leadspaces) &&            ' ' == values.leadspaces &&            ( matches = new RegExp('^('+YamlInline.REGEX_QUOTED_STRING+'|[^ \'"\{\[].*?) *\:(\\s+(.+?))?\\s*$').exec(values.value) )          ) {            matches = {key: matches[1], value: matches[3]};            // this is a compact notation element, add to next block and parse            c = this.getRealCurrentLineNb();            parser = new YamlParser(c);            parser.refs = this.refs;            block = values.value;            if ( !this.isNextLineIndented() )            {              block += "\n"+this.getNextEmbedBlock(this.getCurrentLineIndentation() + 2);            }            data.push(parser.parse(block));            this.refs = parser.refs;          }          else          {            data.push(this.parseValue(values.value));          }        }      }      else if ( values = new RegExp('^('+YamlInline.REGEX_QUOTED_STRING+'|[^ \'"\[\{].*?) *\:(\\s+(.+?))?\\s*$').exec(this.currentLine) )      {        if ( !this.isDefined(data) ) data = {};        if (context && 'sequence' == context) {          throw new YamlParseException('You cannot define a mapping item when in a sequence', this.getRealCurrentLineNb() + 1, this.currentLine);        }        context = 'mapping';        //if ( data instanceof Array ) throw new YamlParseException("Non mapped entry", this.getRealCurrentLineNb() + 1, this.currentLine);        values = {key: values[1], value: values[3]};        try {          key = new YamlInline().parseScalar(values.key);        } catch (e) {          if ( e instanceof YamlParseException ) {            e.setParsedLine(this.getRealCurrentLineNb() + 1);            e.setSnippet(this.currentLine);          }          throw e;        }        if ( '<<' == key )        {          if ( this.isDefined(values.value) && '*' == (values.value+'').charAt(0) )          {            isInPlace = values.value.substr(1);            if ( this.refs[isInPlace] == undefined )            {              throw new YamlParseException('Reference "'+value+'" does not exist', this.getRealCurrentLineNb() + 1, this.currentLine);            }          }          else          {            if ( this.isDefined(values.value) && values.value != '' )            {              value = values.value;            }            else            {              value = this.getNextEmbedBlock();            }            c = this.getRealCurrentLineNb() + 1;            parser = new YamlParser(c);            parser.refs = this.refs;            parsed = parser.parse(value);            this.refs = parser.refs;            var merged = [];            if ( !this.isObject(parsed) )            {              throw new YamlParseException("YAML merge keys used with a scalar value instead of an array", this.getRealCurrentLineNb() + 1, this.currentLine);            }            else if ( this.isDefined(parsed[0]) )            {              // Numeric array, merge individual elements              reverse = this.reverseArray(parsed);              len = reverse.length;              for ( var i = 0; i < len; i++ )              {                var parsedItem = reverse[i];                if ( !this.isObject(reverse[i]) )                {                  throw new YamlParseException("Merge items must be arrays", this.getRealCurrentLineNb() + 1, this.currentLine);                }                merged = this.mergeObject(reverse[i], merged);              }            }            else            {              // Associative array, merge              merged = this.mergeObject(merged, parsed);            }            isProcessed = merged;          }        }        else if ( this.isDefined(values.value) && (matches = /^&([^ ]+) *(.*)/.exec(values.value) ) )        {          matches = {ref: matches[1], value: matches[2]};          isRef = matches.ref;          values.value = matches.value;        }        if ( isProcessed )        {          // Merge keys          data = isProcessed;        }        // hash        else if ( !this.isDefined(values.value) || '' == this.trim(values.value) || this.trim(values.value).charAt(0) == '#' )        {          // if next line is less indented or equal, then it means that the current value is null          if ( this.isNextLineIndented() && !this.isNextLineUnIndentedCollection() )          {            data[key] = null;          }          else          {            c = this.getRealCurrentLineNb() + 1;            parser = new YamlParser(c);            parser.refs = this.refs;            data[key] = parser.parse(this.getNextEmbedBlock());            this.refs = parser.refs;          }        }        else        {          if ( isInPlace )          {            data = this.refs[isInPlace];          }          else          {            data[key] = this.parseValue(values.value);          }        }      }      else      {        // 1-liner followed by newline        if ( 2 == this.lines.length && this.isEmpty(this.lines[1]) )        {          try {            value = new YamlInline().parse(this.lines[0]);          } catch (e) {            if ( e instanceof YamlParseException ) {              e.setParsedLine(this.getRealCurrentLineNb() + 1);              e.setSnippet(this.currentLine);            }            throw e;          }          if ( this.isObject(value) )          {            var first = value[0];            if ( typeof(value) == 'string' && '*' == first.charAt(0) )            {              data = [];              len = value.length;              for ( var i = 0; i < len; i++ )              {                data.push(this.refs[value[i].substr(1)]);              }              value = data;            }          }          return value;        }        alert("Alignment problem found on line " + (this.getRealCurrentLineNb() + 1 )+ "\n" + this.currentLine);      }      if ( isRef )      {        if ( data instanceof Array )          this.refs[isRef] = data[data.length-1];        else        {          var lastKey = null;          for ( var k in data )          {            if ( data.hasOwnProperty(k) ) lastKey = k;          }          this.refs[isRef] = data[k];        }      }    }    return this.isEmpty(data) ? null : data;  },  /**   * Returns the current line number (takes the offset into account).   *   * @return integer The current line number   */  getRealCurrentLineNb: function()  {    return this.currentLineNb + this.offset;  },  /**   * Returns the current line indentation.   *   * @return integer The current line indentation   */  getCurrentLineIndentation: function()  {    return this.currentLine.length - this.currentLine.replace(/^ +/g, '').length;  },  /**   * Returns the next embed block of YAML.   *   * @param integer indentation The indent level at which the block is to be read, or null for default   *   * @return string A YAML string   *   * @throws YamlParseException When indentation problem are detected   */  getNextEmbedBlock: function(indentation)  {    this.moveToNextLine();    var newIndent = null;    var indent = null;    if ( !this.isDefined(indentation) )    {      newIndent = this.getCurrentLineIndentation();      var unindentedEmbedBlock = this.isStringUnIndentedCollectionItem(this.currentLine);      if ( !this.isCurrentLineEmpty() && 0 == newIndent && !unindentedEmbedBlock )      {        throw new YamlParseException('Indentation problem A', this.getRealCurrentLineNb() + 1, this.currentLine);      }    }    else    {      newIndent = indentation;    }    var data = [this.currentLine.substr(newIndent)];    var isUnindentedCollection = this.isStringUnIndentedCollectionItem(this.currentLine);    var continuationIndent = -1;    if (isUnindentedCollection === true) {      continuationIndent = 1 + /^\-((\s+)(.+?))?\s*$/.exec(this.currentLine)[2].length;    }    while ( this.moveToNextLine() )    {      if (isUnindentedCollection && !this.isStringUnIndentedCollectionItem(this.currentLine) && this.getCurrentLineIndentation() != continuationIndent) {        this.moveToPreviousLine();        break;      }      if ( this.isCurrentLineEmpty() )      {        if ( this.isCurrentLineBlank() )        {          data.push(this.currentLine.substr(newIndent));        }        continue;      }      indent = this.getCurrentLineIndentation();      var matches;      if ( matches = /^( *)$/.exec(this.currentLine) )      {        // empty line        data.push(matches[1]);      }      else if ( indent >= newIndent )      {        data.push(this.currentLine.substr(newIndent));      }      else if ( 0 == indent )      {        this.moveToPreviousLine();        break;      }      else      {        throw new YamlParseException('Indentation problem B', this.getRealCurrentLineNb() + 1, this.currentLine);      }    }    return data.join("\n");  },  /**   * Moves the parser to the next line.   *   * @return Boolean   */  moveToNextLine: function()  {    if ( this.currentLineNb >= this.lines.length - 1 )    {      return false;    }    this.currentLineNb++;    this.currentLine = this.lines[this.currentLineNb];    return true;  },  /**   * Moves the parser to the previous line.   */  moveToPreviousLine: function()  {    this.currentLineNb--;    this.currentLine = this.lines[this.currentLineNb];  },  /**   * Parses a YAML value.   *   * @param string value A YAML value   *   * @return mixed A JS value   *   * @throws YamlParseException When reference does not exist   */  parseValue: function(value)  {    if ( '*' == (value+'').charAt(0) )    {      if ( this.trim(value).charAt(0) == '#' )      {        value = (value+'').substr(1, value.indexOf('#') - 2);      }      else      {        value = (value+'').substr(1);      }      if ( this.refs[value] == undefined )      {        throw new YamlParseException('Reference "'+value+'" does not exist', this.getRealCurrentLineNb() + 1, this.currentLine);      }      return this.refs[value];    }    var matches = null;    if ( matches = /^(\||>)(\+|\-|\d+|\+\d+|\-\d+|\d+\+|\d+\-)?( +#.*)?$/.exec(value) )    {      matches = {separator: matches[1], modifiers: matches[2], comments: matches[3]};      var modifiers = this.isDefined(matches.modifiers) ? matches.modifiers : '';      return this.parseFoldedScalar(matches.separator, modifiers.replace(/\d+/g, ''), Math.abs(parseInt(modifiers)));    }    try {      return new YamlInline().parse(value);    } catch (e) {      if ( e instanceof YamlParseException ) {        e.setParsedLine(this.getRealCurrentLineNb() + 1);        e.setSnippet(this.currentLine);      }      throw e;    }  },  /**   * Parses a folded scalar.   *   * @param string  separator  The separator that was used to begin this folded scalar (| or >)   * @param string  indicator  The indicator that was used to begin this folded scalar (+ or -)   * @param integer indentation  The indentation that was used to begin this folded scalar   *   * @return string The text value   */  parseFoldedScalar: function(separator, indicator, indentation)  {    if ( indicator == undefined ) indicator = '';    if ( indentation == undefined ) indentation = 0;    separator = '|' == separator ? "\n" : ' ';    var text = '';    var diff = null;    var notEOF = this.moveToNextLine();    while ( notEOF && this.isCurrentLineBlank() )    {      text += "\n";      notEOF = this.moveToNextLine();    }    if ( !notEOF )    {      return '';    }    var matches = null;    if ( !(matches = new RegExp('^('+(indentation ? this.strRepeat(' ', indentation) : ' +')+')(.*)$').exec(this.currentLine)) )    {      this.moveToPreviousLine();      return '';    }    matches = {indent: matches[1], text: matches[2]};    var textIndent = matches.indent;    var previousIndent = 0;    text += matches.text + separator;    while ( this.currentLineNb + 1 < this.lines.length )    {      this.moveToNextLine();      if ( matches = new RegExp('^( {'+textIndent.length+',})(.+)$').exec(this.currentLine) )      {        matches = {indent: matches[1], text: matches[2]};        if ( ' ' == separator && previousIndent != matches.indent )        {          text = text.substr(0, text.length - 1)+"\n";        }        previousIndent = matches.indent;        diff = matches.indent.length - textIndent.length;        text += this.strRepeat(' ', diff) + matches.text + (diff != 0 ? "\n" : separator);      }      else if ( matches = /^( *)$/.exec(this.currentLine) )      {        text += matches[1].replace(new RegExp('^ {1,'+textIndent.length+'}','g'), '')+"\n";      }      else      {        this.moveToPreviousLine();        break;      }    }    if ( ' ' == separator )    {      // replace last separator by a newline      text = text.replace(/ (\n*)$/g, "\n$1");    }    switch ( indicator )    {      case '':        text = text.replace(/\n+$/g, "\n");        break;      case '+':        break;      case '-':        text = text.replace(/\n+$/g, '');        break;    }    return text;  },  /**   * Returns true if the next line is indented.   *   * @return Boolean Returns true if the next line is indented, false otherwise   */  isNextLineIndented: function()  {    var currentIndentation = this.getCurrentLineIndentation();    var notEOF = this.moveToNextLine();    while ( notEOF && this.isCurrentLineEmpty() )    {      notEOF = this.moveToNextLine();    }    if ( false == notEOF )    {      return false;    }    var ret = false;    if ( this.getCurrentLineIndentation() <= currentIndentation )    {      ret = true;    }    this.moveToPreviousLine();    return ret;  },  /**   * Returns true if the current line is blank or if it is a comment line.   *   * @return Boolean Returns true if the current line is empty or if it is a comment line, false otherwise   */  isCurrentLineEmpty: function()  {    return this.isCurrentLineBlank() || this.isCurrentLineComment();  },  /**   * Returns true if the current line is blank.   *   * @return Boolean Returns true if the current line is blank, false otherwise   */  isCurrentLineBlank: function()  {    return '' == this.trim(this.currentLine);  },  /**   * Returns true if the current line is a comment line.   *   * @return Boolean Returns true if the current line is a comment line, false otherwise   */  isCurrentLineComment: function()  {    //checking explicitly the first char of the trim is faster than loops or strpos    var ltrimmedLine = this.currentLine.replace(/^ +/g, '');    return ltrimmedLine.charAt(0) == '#';  },  /**   * Cleanups a YAML string to be parsed.   *   * @param string value The input YAML string   *   * @return string A cleaned up YAML string   */  cleanup: function(value)  {    value = value.split("\r\n").join("\n").split("\r").join("\n");    if ( !/\n$/.test(value) )    {      value += "\n";    }    // strip YAML header    var count = 0;    var regex = /^\%YAML[: ][\d\.]+.*\n/;    while ( regex.test(value) )    {      value = value.replace(regex, '');      count++;    }    this.offset += count;    // remove leading comments    regex = /^(#.*?\n)+/;    if ( regex.test(value) )    {      var trimmedValue = value.replace(regex, '');      // items have been removed, update the offset      this.offset += this.subStrCount(value, "\n") - this.subStrCount(trimmedValue, "\n");      value = trimmedValue;    }    // remove start of the document marker (---)    regex = /^\-\-\-.*?\n/;    if ( regex.test(value) )    {      trimmedValue = value.replace(regex, '');      // items have been removed, update the offset      this.offset += this.subStrCount(value, "\n") - this.subStrCount(trimmedValue, "\n");      value = trimmedValue;      // remove end of the document marker (...)      value = value.replace(/\.\.\.\s*$/g, '');    }    return value;  },  /**   * Returns true if the next line starts unindented collection   *   * @return Boolean Returns true if the next line starts unindented collection, false otherwise   */  isNextLineUnIndentedCollection: function()  {    var currentIndentation = this.getCurrentLineIndentation();    var notEOF = this.moveToNextLine();    while (notEOF && this.isCurrentLineEmpty()) {      notEOF = this.moveToNextLine();    }    if (false === notEOF) {      return false;    }    var ret = false;    if (      this.getCurrentLineIndentation() == currentIndentation      &&      this.isStringUnIndentedCollectionItem(this.currentLine)    ) {      ret = true;    }    this.moveToPreviousLine();    return ret;  },  /**   * Returns true if the string is unindented collection item   *   * @return Boolean Returns true if the string is unindented collection item, false otherwise   */  isStringUnIndentedCollectionItem: function(string)  {    return (0 === this.currentLine.indexOf('- '));  },  isObject: function(input)  {    return typeof(input) == 'object' && this.isDefined(input);  },  isEmpty: function(input)  {    return input == undefined || input == null || input == '' || input == 0 || input == "0" || input == false;  },  isDefined: function(input)  {    return input != undefined && input != null;  },  reverseArray: function(input /* Array */)  {    var result = [];    var len = input.length;    for ( var i = len-1; i >= 0; i-- )    {      result.push(input[i]);    }    return result;  },  merge: function(a /* Object */, b /* Object */)  {    var c = {};    var i;    for ( i in a )    {      if ( a.hasOwnProperty(i) )        if ( /^\d+$/.test(i) ) c.push(a);        else c[i] = a[i];    }    for ( i in b )    {      if ( b.hasOwnProperty(i) )        if ( /^\d+$/.test(i) ) c.push(b);        else c[i] = b[i];    }    return c;  },  strRepeat: function(str /* String */, count /* Integer */)  {    var i;    var result = '';    for ( i = 0; i < count; i++ ) result += str;    return result;  },  subStrCount: function(string, subString, start, length)  {    var c = 0;    string = '' + string;    subString = '' + subString;    if ( start != undefined ) string = string.substr(start);    if ( length != undefined ) string = string.substr(0, length);    var len = string.length;    var sublen = subString.length;    for ( var i = 0; i < len; i++ )    {      if ( subString == string.substr(i, sublen) )        c++;        i += sublen - 1;    }    return c;  },  trim: function(str /* String */)  {    return (str+'').replace(/^ +/,'').replace(/ +$/,'');  }};/** * YamlEscaper encapsulates escaping rules for single and double-quoted * YAML strings. * * @author Matthew Lewinski <matthew@lewinski.org> */YamlEscaper = function(){};YamlEscaper.prototype ={  /**   * Determines if a JS value would require double quoting in YAML.   *   * @param string value A JS value   *   * @return Boolean True if the value would require double quotes.   */  requiresDoubleQuoting: function(value)  {    return new RegExp(YamlEscaper.REGEX_CHARACTER_TO_ESCAPE).test(value);  },  /**   * Escapes and surrounds a JS value with double quotes.   *   * @param string value A JS value   *   * @return string The quoted, escaped string   */  escapeWithDoubleQuotes: function(value)  {    if(typeof value === "function") {      value = "function"    } else {      value = value + '';    }    var len = YamlEscaper.escapees.length;    var maxlen = YamlEscaper.escaped.length;    var esc = YamlEscaper.escaped;    for (var i = 0; i < len; ++i)      if ( i >= maxlen ) esc.push('');    var ret = '';    ret = value.replace(new RegExp(YamlEscaper.escapees.join('|'),'g'), function(str){      for(var i = 0; i < len; ++i){        if( str == YamlEscaper.escapees[i] )          return esc[i];      }    });    return '"' + ret + '"';  },  /**   * Determines if a JS value would require single quoting in YAML.   *   * @param string value A JS value   *   * @return Boolean True if the value would require single quotes.   */  requiresSingleQuoting: function(value)  {    return /[\s'":{}[\],&*#?]|^[-?|<>=!%@]/.test(value);  },  /**   * Escapes and surrounds a JS value with single quotes.   *   * @param string value A JS value   *   * @return string The quoted, escaped string   */  escapeWithSingleQuotes : function(value)  {    return "'" + value.replace(/'/g, "''") + "'";  }};// Characters that would cause a dumped string to require double quoting.YamlEscaper.REGEX_CHARACTER_TO_ESCAPE = "[\\x00-\\x1f]|\xc2\x85|\xc2\xa0|\xe2\x80\xa8|\xe2\x80\xa9";// Mapping arrays for escaping a double quoted string. The backslash is// first to ensure proper escaping.YamlEscaper.escapees = ['\\\\', '\\"', '"',                   "\x00",  "\x01",  "\x02",  "\x03",  "\x04",  "\x05",  "\x06",  "\x07",                   "\x08",  "\x09",  "\x0a",  "\x0b",  "\x0c",  "\x0d",  "\x0e",  "\x0f",                   "\x10",  "\x11",  "\x12",  "\x13",  "\x14",  "\x15",  "\x16",  "\x17",                   "\x18",  "\x19",  "\x1a",  "\x1b",  "\x1c",  "\x1d",  "\x1e",  "\x1f",                   "\xc2\x85", "\xc2\xa0", "\xe2\x80\xa8", "\xe2\x80\xa9"];YamlEscaper.escaped = ['\\"', '\\\\', '\\"',                   "\\0",   "\\x01", "\\x02", "\\x03", "\\x04", "\\x05", "\\x06", "\\a",                   "\\b",   "\\t",   "\\n",   "\\v",   "\\f",   "\\r",   "\\x0e", "\\x0f",                   "\\x10", "\\x11", "\\x12", "\\x13", "\\x14", "\\x15", "\\x16", "\\x17",                   "\\x18", "\\x19", "\\x1a", "\\e",   "\\x1c", "\\x1d", "\\x1e", "\\x1f",                   "\\N", "\\_", "\\L", "\\P"];/** * YamlUnescaper encapsulates unescaping rules for single and double-quoted * YAML strings. * * @author Matthew Lewinski <matthew@lewinski.org> */var YamlUnescaper = function(){};YamlUnescaper.prototype ={  /**   * Unescapes a single quoted string.   *   * @param string value A single quoted string.   *   * @return string The unescaped string.   */  unescapeSingleQuotedString: function(value)  {    return value.replace(/''/g, "'");  },  /**   * Unescapes a double quoted string.   *   * @param string value A double quoted string.   *   * @return string The unescaped string.   */  unescapeDoubleQuotedString: function(value)  {    var callback = function(m) {      return new YamlUnescaper().unescapeCharacter(m);    };    // evaluate the string    return value.replace(new RegExp(YamlUnescaper.REGEX_ESCAPED_CHARACTER, 'g'), callback);  },  /**   * Unescapes a character that was found in a double-quoted string   *   * @param string value An escaped character   *   * @return string The unescaped character   */  unescapeCharacter: function(value)  {    switch (value.charAt(1)) {      case '0':        return String.fromCharCode(0);      case 'a':        return String.fromCharCode(7);      case 'b':        return String.fromCharCode(8);      case 't':        return "\t";      case "\t":        return "\t";      case 'n':        return "\n";      case 'v':        return String.fromCharCode(11);      case 'f':        return String.fromCharCode(12);      case 'r':        return String.fromCharCode(13);      case 'e':        return "\x1b";      case ' ':        return ' ';      case '"':        return '"';      case '/':        return '/';      case '\\':        return '\\';      case 'N':        // U+0085 NEXT LINE        return "\x00\x85";      case '_':        // U+00A0 NO-BREAK SPACE        return "\x00\xA0";      case 'L':        // U+2028 LINE SEPARATOR        return "\x20\x28";      case 'P':        // U+2029 PARAGRAPH SEPARATOR        return "\x20\x29";      case 'x':        return this.pack('n', new YamlInline().hexdec(value.substr(2, 2)));      case 'u':        return this.pack('n', new YamlInline().hexdec(value.substr(2, 4)));      case 'U':        return this.pack('N', new YamlInline().hexdec(value.substr(2, 8)));    }  },  /**   * @see http://phpjs.org/functions/pack   * @warning only modes used above copied   */   pack: function(B){var g=0,o=1,m="",l="",z=0,p=[],E,s,C,I,h,c;var d,b,x,H,u,e,A,q,D,t,w,a,G,F,y,v,f;while(g<B.length){E=B.charAt(g);s="";g++;while((g<B.length)&&(B.charAt(g).match(/[\d\*]/)!==null)){s+=B.charAt(g);g++}if(s===""){s="1"}switch(E){case"n":if(s==="*"){s=arguments.length-o}if(s>(arguments.length-o)){throw new Error("Warning:  pack() Type "+E+": too few arguments")}for(z=0;z<s;z++){m+=String.fromCharCode(arguments[o]>>8&255);m+=String.fromCharCode(arguments[o]&255);o++}break;case"N":if(s==="*"){s=arguments.length-o}if(s>(arguments.length-o)){throw new Error("Warning:  pack() Type "+E+": too few arguments")}for(z=0;z<s;z++){m+=String.fromCharCode(arguments[o]>>24&255);m+=String.fromCharCode(arguments[o]>>16&255);m+=String.fromCharCode(arguments[o]>>8&255);m+=String.fromCharCode(arguments[o]&255);o++}break;default:throw new Error("Warning:  pack() Type "+E+": unknown format code")}}if(o<arguments.length){throw new Error("Warning: pack(): "+(arguments.length-o)+" arguments unused")}return m}}// Regex fragment that matches an escaped character in a double quoted// string.// why escape quotes, ffs!YamlUnescaper.REGEX_ESCAPED_CHARACTER = '\\\\([0abt\tnvfre "\\/\\\\N_LP]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})';/** * YamlDumper dumps JS variables to YAML strings. * * @author Fabien Potencier <fabien@symfony.com> */var YamlDumper = function(){};YamlDumper.prototype ={  /**   * Dumps a JS value to YAML.   *   * @param mixed  input  The JS value   * @param integer inline The level where you switch to inline YAML   * @param integer indent The level o indentation indentation (used internally)   *   * @return string The YAML representation of the JS value   */  dump: function(input, inline, indent)  {    if ( inline == null ) inline = 0;    if ( indent == null ) indent = 0;    var output = '';    var prefix = indent ? this.strRepeat(' ', indent) : '';    var yaml;    if (!this.numSpacesForIndentation) this.numSpacesForIndentation = 2;    if ( inline <= 0 || !this.isObject(input) || this.isEmpty(input) )    {      yaml = new YamlInline();      output += prefix + yaml.dump(input);    }    else    {      var isAHash = !this.arrayEquals(this.getKeys(input), this.range(0,input.length - 1));      var willBeInlined;      for ( var key in input )      {        if ( input.hasOwnProperty(key) )        {          willBeInlined = inline - 1 <= 0 || !this.isObject(input[key]) || this.isEmpty(input[key]);          if ( isAHash ) yaml = new YamlInline();          output +=            prefix + '' +            (isAHash ? yaml.dump(key)+':' : '-') + '' +            (willBeInlined ? ' ' : "\n") + '' +            this.dump(input[key], inline - 1, (willBeInlined ? 0 : indent + this.numSpacesForIndentation)) + '' +            (willBeInlined ? "\n" : '');        }      }    }    return output;  },  strRepeat: function(str /* String */, count /* Integer */)  {    var i;    var result = '';    for ( i = 0; i < count; i++ ) result += str;    return result;  },  isObject: function(input)  {    return this.isDefined(input) && typeof(input) == 'object';  },  isEmpty: function(input)  {    var ret = input == undefined || input == null || input == '' || input == 0 || input == "0" || input == false;    if ( !ret && typeof(input) == "object" && !(input instanceof Array)){      var propCount = 0;      for ( var key in input )        if ( input.hasOwnProperty(key) ) propCount++;      ret = !propCount;    }    return ret;  },  isDefined: function(input)  {    return input != undefined && input != null;  },  getKeys: function(tab)  {    var ret = [];    for ( var name in tab )    {      if ( tab.hasOwnProperty(name) )      {        ret.push(name);      }    }    return ret;  },  range: function(start, end)  {    if ( start > end ) return [];    var ret = [];    for ( var i = start; i <= end; i++ )    {      ret.push(i);    }    return ret;  },  arrayEquals: function(a,b)  {    if ( a.length != b.length ) return false;    var len = a.length;    for ( var i = 0; i < len; i++ )    {      if ( a[i] != b[i] ) return false;    }    return true;  }};hyle.yaml = YAML;})();// Generated by CoffeeScript 1.10.0// Generated by CoffeeScript 1.10.0var Esy, dump, log;Esy = (function() {  function Esy() {}  Esy.prototype.initialize = function() {    this.ui = new EsyUi;    this.http = new EsyHttp;    this.file = new EsyFile;    this.color = new EsyColor;    this.project = new EsyProject;    this.composition = new EsyComposition;    if (esy.debug) {      return this.selfBuild((new File($.fileName)).parent.parent.path);    } else {      this.updater = new EsyUpdater({        repo: "seblavoie/esy",        file: "esy.jsx",        version: "v0.0.2",        destination: Folder.appPackage.path + "/Scripts/startup"      });      return this.updater.checkForUpdate();    }  };  Esy.prototype.selfBuild = function(path) {    return esy.file.buildExtendScript(path + "/lib/esy.js", [path + "/esy.jsx"]);  };  Esy.prototype.listProperties = function(obj) {    var i, property, ref, results;    this.log("Esy.listProperties:");    results = [];    for (property = i = 1, ref = obj.numProperties; 1 <= ref ? i <= ref : i >= ref; property = 1 <= ref ? ++i : --i) {      results.push(this.log(property));    }    return results;  };  Esy.prototype.log = function(str) {    try {      return $.write((str != null ? str.toString() : void 0) + "\n");    } catch (undefined) {}  };  Esy.prototype.dump = function(obj, name, line) {    var propertyName, propertyValue;    if (line == null) {      line = true;    }    if (obj) {      if (name == null) {        name = "[" + (typeof obj) + "]";      }      if (line) {        this.log("\n------------------------");      }      this.log("Dump of " + name + ":\n");      for (propertyName in obj) {        propertyValue = obj[propertyName];        this.log("  " + propertyName + ": " + (propertyValue != null ? propertyValue.toString() : void 0) + " \n");      }      if (line) {        return this.log("------------------------");      }    }  };  Esy.prototype.extend = function(sourceObject, defaultObject) {    var propertyName, propertyValue;    for (propertyName in defaultObject) {      propertyValue = defaultObject[propertyName];      if (!sourceObject[propertyName]) {        sourceObject[propertyName] = propertyValue;      }    }    return sourceObject;  };  return Esy;})();log = function(log) {  return esy.log(log);};dump = function(obj, name, line) {  if (line == null) {    line = true;  }  return esy.dump(obj, name, line);};// Generated by CoffeeScript 1.10.0var EsyUpdater;EsyUpdater = (function() {  function EsyUpdater(opts) {    this.repo = opts.repo, this.file = opts.file, this.destination = opts.destination;    this.localVersion = opts.version;    this.username = encodeURIComponent(system.userName);    this.data;    this.remoteVersion;    this.connection;  }  EsyUpdater.prototype.initialize = function() {};  EsyUpdater.prototype.makeConnection = function() {};  EsyUpdater.prototype.getLatestVersion = function() {};  EsyUpdater.prototype.checkIfLatest = function() {};  EsyUpdater.prototype.checkForUpdate = function() {};  EsyUpdater.prototype.update = function() {};  return EsyUpdater;})();// Generated by CoffeeScript 1.10.0var EsyColor;EsyColor = (function() {  function EsyColor() {}  EsyColor.prototype.hexToRgb = function(hex) {    var b, g, r;    hex = hex.replace("#", "");    hex = parseInt(hex, 16);    r = hex >> 16;    g = (hex & 0x00ff00) >> 8;    b = hex & 0xff;    return [r, g, b];  };  EsyColor.prototype.rgbToHex = function(rgb) {    var componentToHex;    componentToHex = function(c) {      var hex;      hex = c.toString(16);      if (hex.length === 1) {        return "0" + hex;      } else {        return hex;      }    };    return componentToHex(rgb[0] * 255) + componentToHex(rgb[1] * 255) + componentToHex(rgb[2] * 255);  };  EsyColor.prototype.hexToHsl = function(hex) {    var b, g, r;    hex = hex.replace("#", "");    hex = parseInt(hex, 16);    r = hex >> 16;    g = (hex & 0x00ff00) >> 8;    b = hex & 0xff;    return [r / 255, g / 255, b / 255];  };  return EsyColor;})();// Generated by CoffeeScript 1.10.0var EsyFile;EsyFile = (function() {  function EsyFile() {}  EsyFile.prototype["delete"] = function(filepath) {    var file;    if (File(filepath)) {      file = File(filepath);    }    return file.remove();  };  EsyFile.prototype.append = function(filepath, content) {    var file;    file = File(filepath);    file.open("a");    file.write(content);    file.close();    return file;  };  EsyFile.prototype.buildExtendScript = function(filepath, destinations) {    var content, destination, i, len, read, results;    content = this.read(filepath);    content = content.replace("debug = true", "debug = false");    read = (function(_this) {      return function(str, p1) {        return _this.read((_this.path(filepath)) + "/" + p1);      };    })(this);    content = content.replace(/#include \"(.*)\";/g, read);    if (typeof destinations === "string") {      destinations = [destinations];    }    results = [];    for (i = 0, len = destinations.length; i < len; i++) {      destination = destinations[i];      results.push(this.create("" + (destination.toString()), content));    }    return results;  };  EsyFile.prototype.create = function(filepath, content, overwrite) {    var file;    if (content == null) {      content = "";    }    if (overwrite == null) {      overwrite = true;    }    if (overwrite) {      this["delete"](filepath);    }    file = File(filepath);    file.open("w");    file.write(content);    file.close();    return file;  };  EsyFile.prototype.exists = function(filepath) {    var file;    file = File(filepath);    if (file.created) {      return file;    } else {      return false;    }  };  EsyFile.prototype.read = function(filepath) {    var content, file;    file = File(filepath);    file.open("r");    content = file.read();    file.close();    return content;  };  EsyFile.prototype.folderName = function(filepath) {    var folderName;    folderName = this.filename(filepath);    return folderName;  };  EsyFile.prototype.fileName = function(filepath) {    var filename;    filename = filepath.substr(filepath.lastIndexOf('/') + 1);    return filename;  };  EsyFile.prototype.path = function(filepath) {    var filename;    filename = filepath.substr(0, filepath.lastIndexOf('/'));    return filename;  };  return EsyFile;})();// Generated by CoffeeScript 1.10.0var EsyHttp;EsyHttp = (function() {  function EsyHttp() {}  EsyHttp.prototype.open = function(url) {    var command;    if ($.os.indexOf("Windows") !== -1) {      url = url.replace(/&/g, "^&");      command = "cmd /c 'explorer " + url + "'";    } else {      command = "open '" + url + "'";    }    return system.callSystem(command);  };  EsyHttp.prototype.get = function(url) {    var call, conn, domain, httpPrefix, port, reply, typeMatch;    port = "80";    httpPrefix = url.match(/http:\/\//);    domain = (httpPrefix == null ? url.split("/")[0] + ":" + port : url.split("/")[2] + ":" + port);    call = "GET " + (httpPrefix == null ? "http://" + url : url) + " HTTP/1.0\r\nHost:" + (httpPrefix == null ? url.split("/")[0] : url.split("/")[2]) + "\r\nConnection: close\r\n\r\n";    reply = new String();    conn = new Socket();    typeMatch = url.match(/(\.)(\w{3,4}\b)/g);    if (conn.open(domain, "binary")) {      conn.write(call);      reply = conn.read(9999999999);      conn.close();    } else {      reply = "";      true;    }    return reply.substr(reply.indexOf("\r\n\r\n") + 4);  };  return EsyHttp;})();// Generated by CoffeeScript 1.10.0var EsyUi;EsyUi = (function() {  function EsyUi() {}  return EsyUi;})();// Generated by CoffeeScript 1.10.0var EsyProject;EsyProject = (function() {  function EsyProject() {}  EsyProject.prototype.hasItems = function() {    return app.project.numItems > 0;  };  EsyProject.prototype.first = function(itemName) {    var compositions;    compositions = this.find(itemName);    return compositions[0];  };  EsyProject.prototype.find = function(itemName) {    var compositions, i, item, j, ref;    if (this.hasItems) {      compositions = [];      for (i = j = 1, ref = app.project.numItems; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {        if (app.project.item(i).name === itemName) {          item = app.project.item(i);          if (item instanceof CompItem) {            compositions.push(item);          }        }      }    }    return compositions;  };  EsyProject.prototype.filter = function(expression, type) {    var i, item, items, j, passes, ref;    items = [];    if (this.hasItems) {      for (i = j = 1, ref = app.project.numItems; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {        item = app.project.item(i);        passes = true;        if (expression) {          if (!expression.test(item.name)) {            passes = false;          }        }        if (type) {          if (item.typeName !== type) {            passes = false;          }        }        if (passes) {          items.push(item);        }      }    }    return items;  };  return EsyProject;})();// Generated by CoffeeScript 1.10.0var EsyComposition;EsyComposition = (function() {  function EsyComposition() {}  EsyComposition.prototype.hasLayers = function(composition) {    return composition.numLayers > 0;  };  EsyComposition.prototype.find = function(composition, layerName) {    var i, j, layers, ref;    layers = [];    if (composition) {      if (this.hasLayers(composition)) {        for (i = j = 1, ref = composition.numLayers; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {          if (composition.layers[i].name === layerName) {            layers.push(composition.layers[i]);          }        }      }    }    return layers;  };  EsyComposition.prototype.first = function(composition, layerName) {    var layers;    layers = this.find(composition, layerName);    return layers[0];  };  return EsyComposition;})();var esy;esy = {};esy = new Esy();esy.container = this;esy.debug = false;esy.initialize();// Generated by CoffeeScript 1.10.0Hyle.Parser = (function() {  function Parser() {    this.data = null;    this.cache = {      content: {}    };    this.fileItemsCollection = new Hyle.FileItemsCollection;    this.folderItemsCollection = new Hyle.FolderItemsCollection;    this.compositionItemsCollection = new Hyle.CompositionItemsCollection;    this.layersCollection = new Hyle.LayersCollection;    this.fileItemsFactory = new Object;    this.folderItemsFactory = new Object;    this.compositionItemsFactory = new Object;    this.layersFactory = new Object;  }  Parser.prototype.parse = function(data) {    this.data = this.parseYaml(data);    return this.processData();  };  Parser.prototype.processData = function() {    this.processRootData();    return this.finishProcess();  };  Parser.prototype.processRootData = function() {    if (this.data) {      if (this.data.folders) {        this.createFolders(this.data.folders);      }      this.createFileImports(this.data.files);      if (this.data.compositions) {        this.createCompositions(this.data.compositions);      }      if (this.data.layers) {        return this.createLayers(this.data.layers);      }    }  };  Parser.prototype.preParseYaml = function(yaml) {    yaml = yaml.replace(/\t/g, "  ");    yaml = yaml.replace(/(color ?(.+)?): ([0-9]{6})/gi, "$1: '$3'");    yaml = yaml.replace(/: ?([0-9\.]+[^0-9\n\r]{2,})/gi, ": '$1'");    yaml = yaml.replace(/\{\{|\}\}/g, "%%");    yaml = yaml.replace(/null/g, "'Null'");    return yaml;  };  Parser.prototype.parseYaml = function(yaml) {    yaml = this.preParseYaml(yaml);    yaml = hyle.yaml.parse(yaml);    return yaml;  };  Parser.prototype.finishProcess = function() {};  Parser.prototype.createFileImports = function(filesData) {    if (filesData == null) {      filesData = [];    }    return this.fileItemsFactory = new Hyle.FileItemsFactory(filesData);  };  Parser.prototype.createFolders = function(foldersData) {    return this.folderItemsFactory = new Hyle.FolderItemsFactory(foldersData);  };  Parser.prototype.createCompositions = function(compositionsData) {    return this.compositionItemsFactory = new Hyle.CompositionItemsFactory(compositionsData);  };  Parser.prototype.createLayers = function(layersData) {    return this.layersFactory = new Hyle.LayersFactory(layersData);  };  return Parser;})();// Generated by CoffeeScript 1.10.0Hyle.Debugger = (function() {  function Debugger() {}  Debugger.prototype.initialize = function() {    if (hyle.debug) {      return this.testParser();    }  };  Debugger.prototype.testParser = function() {    this.testFolders();    this.testCompositions();    this.testLayers();    this.testShapes();    this.testTexts();    this.testMasks();    this.testEffects();    return this.testKeyframes();  };  Debugger.prototype.testComposer = function() {    return esy.file.create("~/Dropbox/_Personnal/code/scripts/hyle/data/hyle-compose.hyle", hyle.api.compose());  };  Debugger.prototype.testFolders = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/folders.hyle");  };  Debugger.prototype.testCompositions = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/compositions.hyle");  };  Debugger.prototype.testLayers = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/layers.hyle");  };  Debugger.prototype.testShapes = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/shapeLayers.hyle");  };  Debugger.prototype.testTexts = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/textLayers.hyle");  };  Debugger.prototype.testMasks = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/masks.hyle");  };  Debugger.prototype.testEffects = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/effects.hyle");  };  Debugger.prototype.testKeyframes = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/keyframes.hyle");  };  Debugger.prototype.testTemp = function() {    return hyle.api.parseFile("~/Dropbox/_Personnal/code/scripts/hyle/data/temp.hyle");  };  return Debugger;})();// Generated by CoffeeScript 1.10.0Hyle.Api = (function() {  function Api() {}  Api.prototype.parse = function(data) {    hyle.parse(data);    return this;  };  Api.prototype.parseFile = function(file) {    hyle.parse(esy.file.read(file));    return this;  };  Api.prototype.compose = function() {    return hyle.composer.compose();  };  Api.prototype.execute = function(fn) {    fn();    return this;  };  Api.prototype.then = function(fn) {    this.execute(fn);    return this;  };  return Api;})();// Generated by CoffeeScript 1.10.0Hyle.Composer = (function() {  function Composer() {    this.composedContent = {      folders: [],      compositions: [],      files: []    };  }  Composer.prototype.compose = function() {    var composedContent;    this.listItems(app.project.numItems);    composedContent = this.stringify(this.composedContent);    composedContent = this.cleanUp(composedContent);    return composedContent;  };  Composer.prototype.cleanUp = function(content) {    content = content.replace(/\-(\r\n|\n|\r)/gm, "-");    content = content.replace(/\- {2,}/gm, "- ");    content = content.replace(/\: \'(.+)'/gm, ": $1");    return content;  };  Composer.prototype.append = function(category, content) {    if (!isObjectEmpty(content)) {      return this.composedContent[category].push(content);    }  };  Composer.prototype.stringify = function(composedContent) {    var content;    content = hyle.yaml.stringify(composedContent, 50, 2);    return content;  };  Composer.prototype.listItems = function(dataSet) {    var i, j, ref, results;    results = [];    for (i = j = 1, ref = dataSet; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      if (app.project.item(i) instanceof FolderItem) {        this.listFolder(app.project.item(i));      }      if (app.project.item(i) instanceof CompItem) {        this.listComposition(app.project.item(i));      }      if (app.project.item(i) instanceof FootageItem) {        results.push(this.listFile(app.project.item(i)));      } else {        results.push(void 0);      }    }    return results;  };  Composer.prototype.listFolder = function(folderItem) {    var folderItemInterpretor;    folderItemInterpretor = new Hyle.FolderItemInterpretor(folderItem);    return this.append("folders", folderItemInterpretor.compact());  };  Composer.prototype.listComposition = function(compositionItem) {    var compositionItemInterpretor;    compositionItemInterpretor = new Hyle.CompositionItemInterpretor(compositionItem);    return this.append("compositions", compositionItemInterpretor.compact());  };  Composer.prototype.listFile = function(fileItem) {    var fileItemInterpretor;    fileItemInterpretor = new Hyle.FileItemInterpretor(fileItem);    return this.append("files", fileItemInterpretor.compact());  };  return Composer;})();// Generated by CoffeeScript 1.10.0var clone, dotAccess, invert, isFoundIn, isObjectAndNotArray, isObjectEmpty, logError, toDict;isObjectEmpty = function(obj) {  var r;  r = false;  if (obj) {    if (obj.length > 0) {      r = true;    }  }  return r;};isObjectAndNotArray = function(obj) {  return typeof obj === "object" && !(obj instanceof Array);};isFoundIn = function(term, array) {  return array.indexOf(term) !== -1;};toDict = function(array, key) {  var dict, i, obj;  dict = {};  i = 0;  while (i < array.length) {    obj = array[i];    if (obj[key] !== null) {      dict[obj[key]] = obj;    }    i++;  }  return dict;};logError = function(error) {  return esy.file.create("/" + $.appData + "/Hyle/errors.txt", (Date()) + "\n" + (error.toString()), false);};String.prototype.capitalize = function() {  return this.replace(/(?:^|\s)\S/g, function(a) {    return a.toUpperCase();  });};String.prototype.toTitleCase = function() {  var i, lowers, str, uppers;  i = void 0;  str = void 0;  lowers = void 0;  uppers = void 0;  str = this.replace(/([^\W_]+[^\s-]*) */g, function(txt) {    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();  });  lowers = ["A", "An", "The", "And", "But", "Or", "For", "Nor", "As", "At", "By", "For", "From", "In", "Into", "Near", "Of", "On", "Onto", "To", "With"];  i = 0;  while (i < lowers.length) {    str = str.replace(new RegExp("\\s" + lowers[i] + "\\s", "g"), function(txt) {      return txt.toLowerCase();    });    i++;  }  uppers = ["Id", "Tv"];  i = 0;  while (i < uppers.length) {    str = str.replace(new RegExp("\\b" + uppers[i] + "\\b", "g"), uppers[i].toUpperCase());    i++;  }  return str;};invert = function(obj) {  var new_obj, prop;  new_obj = {};  for (prop in obj) {    if (obj.hasOwnProperty(prop)) {      new_obj[obj[prop]] = prop;    }  }  return new_obj;};clone = function(obj) {  var key, r, temp;  r = obj;  if (typeof obj === "object") {    temp = {};    for (key in obj) {      temp[key] = obj[key];    }  }  r = temp;  return r;};dotAccess = function(obj, str) {  var i;  str = str.split('.');  i = 0;  while (i < str.length) {    try {      obj = obj[str[i]];    } catch (undefined) {}    i++;  }  return obj;};// Generated by CoffeeScript 1.10.0var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };Hyle.Object = (function() {  function Object() {}  Object.prototype.extend = function(sourceObject, defaultObject, adapt) {    var property, propertyName, propertyValue;    if (adapt == null) {      adapt = false;    }    for (propertyName in defaultObject) {      propertyValue = defaultObject[propertyName];      if (sourceObject[propertyName]) {        propertyValue = sourceObject[propertyName];      }      property = new Hyle.PropertyInstance(propertyName, propertyValue);      property = property.adapt();      if (!sourceObject[property.getPropertyName()]) {        sourceObject[property.getPropertyName()] = property.getPropertyValue();      }    }    return sourceObject;  };  Object.prototype.apply = function(object, data, adapt) {    var property, propertyName, propertyValue;    if (adapt == null) {      adapt = false;    }    for (propertyName in data) {      propertyValue = data[propertyName];      if (indexOf.call(this.ignoredProperties, propertyName) < 0) {        property = new Hyle.PropertyInstance(propertyName, propertyValue);        if (adapt) {          property.adapt();        }        try {          property.apply(object);        } catch (undefined) {}      }    }    return object;  };  Object.prototype.adaptObject = function(objectData, opts) {    var property, propertyName, propertyValue;    if (opts == null) {      opts = {};    }    for (propertyName in objectData) {      propertyValue = objectData[propertyName];      property = new Hyle.PropertyInstance(propertyName, propertyValue);      property = property.adapt(opts);      delete objectData[propertyName];      objectData[property.getPropertyName()] = property.getPropertyValue();    }    return objectData;  };  Object.prototype.buffer = function(target, propertyName) {    var bufferCounter, r;    bufferCounter = 0;    r = function() {      if (target[propertyName]) {        return true;      } else {        if (bufferCounter < 10) {          bufferCounter++;          $.sleep(100);          return r();        } else {          return false;        }      }    };    return r();  };  Object.prototype.compact = function(object, opts) {    var data, e, error, key, propertyInterpretor, value;    if (opts == null) {      opts = {};    }    data = {};    if (this.validateNotIgnoredItem(object)) {      for (key in object) {        try {          value = object[key];        } catch (undefined) {}        try {          if (value && typeof object[key] !== "function") {            if (indexOf.call(this.ignoredProperties, key) < 0) {              propertyInterpretor = new Hyle.PropertyInterpretor(key, value);              if (propertyInterpretor.validateNotInIgnoredValues(this.ignoredValues)) {                if (opts.bypassDefaults === true || propertyInterpretor.validateInAndNotSameAsDefaults(this.defaults)) {                  propertyInterpretor.adapt();                  data[propertyInterpretor.getPropertyName()] = propertyInterpretor.getStringifiedPropertyValue();                }              }            }          }        } catch (error) {          e = error;          logError(e);        }      }      return data;    } else {      return false;    }  };  Object.prototype.validateNotIgnoredItem = function(object) {    var key, r;    r = true;    if (this.ignoredItems) {      for (key in this.ignoredItems) {        if (object[key] === this.ignoredItems[key]) {          r = false;        }      }    }    return r;  };  return Object;})();// Generated by CoffeeScript 1.10.0Hyle.Factory = (function() {  function Factory() {    this;  }  return Factory;})();// Generated by CoffeeScript 1.10.0Hyle.Collection = (function() {  function Collection() {}  Collection.prototype.getAVItem = function(nameOrId) {    var r;    switch (typeof nameOrId) {      case "string":        r = this.getAVItemByName(nameOrId);        break;      case "number":        r = this.getAVItemById(nameOrId);    }    return r;  };  Collection.prototype.add = function(object) {};  Collection.prototype.find = function(key) {};  Collection.prototype.getAVItemByName = function(name) {    var i, j, ref;    for (i = j = 1, ref = app.project.numItems; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      if (app.project.item(i).name === name) {        return app.project.item(i);      }    }  };  Collection.prototype.getAVItemById = function(_id) {    var ref;    return (ref = this.cache.content[_id]) != null ? ref.AVItem : void 0;  };  Collection.prototype.getFromCache = function(_id) {    return this.cache.content[_id];  };  return Collection;})();// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.Item = (function(superClass) {  extend(Item, superClass);  function Item() {    this.defaults = {};    this.data = {};    this.item = {};    this.setDefaults({      name: null,      parentFolder: null,      folder: null,      comment: "",      selected: false    });  }  Item.prototype.initiate = function(data) {    return this.data = this.extend(data, this.defaults);  };  Item.prototype.setDefaults = function(defaults) {    var key, results;    results = [];    for (key in defaults) {      results.push(this.defaults[key] = defaults[key]);    }    return results;  };  Item.prototype.store = function(item) {    this.item = item;    this.data = this.adaptObject(this.data);    return this.apply(this.item, this.data);  };  Item.prototype.setParentFolder = function(parentFolder) {    return this.item.parentFolder = parentFolder;  };  return Item;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.Property = (function(superClass) {  extend(Property, superClass);  function Property() {    this.evalIfDirective = bind(this.evalIfDirective, this);    this.getEasingValue = bind(this.getEasingValue, this);    this.setTemporalEaseAtKey = bind(this.setTemporalEaseAtKey, this);  }  Property.prototype.getPropertyName = function() {    return this.propertyName;  };  Property.prototype.getPropertyValue = function() {    return this.propertyValue;  };  Property.prototype.setValues = function(propertyAlias, propertyValue) {    if (propertyValue.value) {      this.setPropertyValue(propertyAlias, propertyValue.value);    }    if (propertyValue.expression) {      this.setPropertyExpression(propertyAlias, propertyValue.expression);    }    if (propertyValue.keyframes) {      this.setPropertyValueAtTime(propertyAlias, propertyValue.keyframes);    }    try {      return this.setPropertyValue(propertyAlias, propertyValue);    } catch (undefined) {}  };  Property.prototype.setPropertyValue = function(propertyAlias, propertyValue) {    try {      return propertyAlias.setValue(propertyValue);    } catch (undefined) {}  };  Property.prototype.setPropertyExpression = function(propertyAlias, propertyExpression) {    return propertyAlias.expression = propertyExpression;  };  Property.prototype.setPropertyValueAtTime = function(propertyAlias, keyframes) {    var i, keyframe, len, previousKeyframe, results, timespan;    results = [];    for (i = 0, len = keyframes.length; i < len; i++) {      keyframe = keyframes[i];      if (keyframe.time == null) {        keyframe.time = keyframe[0];      }      keyframe.time = this.convertToFrameIfNeeded(keyframe.time);      if (keyframe.value == null) {        keyframe.value = keyframe[1];      }      propertyAlias.setValueAtTime(keyframe.time, keyframe.value);      if (keyframe.easing) {        if (previousKeyframe) {          timespan = keyframe.time * 24 - previousKeyframe.time * 24;          keyframe.value = keyframe.value - previousKeyframe.value;        } else {          timespan = 0;        }        this.setPropertyValueAtTimeEasing(propertyAlias, keyframe.easing, propertyAlias.numKeys, keyframe.value, timespan);      }      results.push(previousKeyframe = keyframe);    }    return results;  };  Property.prototype.validateInAndNotSameAsDefaults = function(defaults, key) {    if (defaults.hasOwnProperty(this.propertyName)) {      if (defaults[this.propertyName] !== this.propertyValue) {        return true;      }    } else {      return false;    }  };  Property.prototype.setPropertyValueAtTimeEasing = function(propertyAlias, easingType, keyframeId, keyframeValue, timespan) {    var easeIn, easeOut, easing, i, len, propertyValue;    if (keyframeValue instanceof Array) {      easing = null;      easeIn = [];      easeOut = [];      for (i = 0, len = keyframeValue.length; i < len; i++) {        propertyValue = keyframeValue[i];        easing = this.getEasingValue(easingType, propertyValue, timespan);        easeIn.push(easing.easeIn);        easeOut.push(easing.easeOut);      }      if (easeIn.length < 3) {        easeIn.push(easing.easeIn);        easeOut.push(easing.easeOut);      }    } else {      easing = this.getEasingValue(easingType, keyframeValue, timespan);      easeIn = [easing.easeIn];      easeOut = [easing.easeOut];    }    return this.setTemporalEaseAtKey(propertyAlias, keyframeId, easeIn, easeOut);  };  Property.prototype.setTemporalEaseAtKey = function(propertyAlias, keyframeId, easeIn, easeOut) {    return propertyAlias.setTemporalEaseAtKey(keyframeId, easeIn, easeOut);  };  Property.prototype.getEasingValue = function(easingType, keyframeValue, timespan) {    var easeIn, easeOut, easings;    switch (easingType) {      case "easy ease":      case "easy":        easeIn = new KeyframeEase(0, 33.3);        easeOut = new KeyframeEase(0, 33.3);        break;      case "ease in":      case "in":        easeIn = new KeyframeEase(0, 33.3);        easeOut = new KeyframeEase(keyframeValue * timespan / app.project.activeItem.frameRate, 33.3);        break;      case "ease out":      case "out":        easeIn = new KeyframeEase(keyframeValue * timespan / app.project.activeItem.frameRate, 33.3);        easeOut = new KeyframeEase(0, 33.3);    }    easings = {      easeIn: easeIn,      easeOut: easeOut    };    return easings;  };  Property.prototype.evalIfDirective = function(propertyValue) {    if (typeof propertyValue === "string") {      propertyValue = propertyValue.replace(/(?:%%)(.+?)(?:%%)/g, function(match, p1) {        return eval(p1);      });    }    return propertyValue;  };  Property.prototype.convertToFrameIfNeeded = function(propertyValue) {    var framerate, r, ref;    if (typeof propertyValue === "string") {      if ((ref = propertyValue.match(/\w+$/)[0]) === "f" || ref === "frame" || ref === "frames") {        if (app.project.activeItem) {          framerate = app.project.activeItem.frameRate;        } else {          framerate = 24;        }        r = parseInt(propertyValue.replace(/\w+[.!?]?$/, '')) / framerate;      }    } else {      r = propertyValue;    }    return r;  };  Property.prototype.getPropertyNameTranslations = function(opts, dict) {    var scope, translations, translationsArray;    translations = {      "global": [        {          o: "_id",          t: ["id"]        }, {          o: "pixelAspect",          t: ["pixel aspect"]        }, {          o: "parentFolder",          t: ["folder", "parent folder"]        }, {          o: "valueAtTime",          t: ["keyframes"]        }, {          o: "frameRate",          t: ["frame rate"]        }      ],      "layer": [        {          o: "sourceText",          t: ["text"]        }, {          o: "blendingMode",          t: ["blending mode"]        }, {          o: "motionBlur",          t: ["motion blur"]        }, {          o: "trackMatteType",          t: ["track matte"]        }, {          o: "parent",          t: ["parent layer"]        }, {          o: "parentComp",          t: ["comp", "composition", "parent composition"]        }, {          o: "guideLayer",          t: ["guide layer", "guide"]        }, {          o: "adjustmentLayer",          t: ["adjustment layer", "adjustment"]        }, {          o: "startTime",          t: ["start time"]        }, {          o: "inPoint",          t: ["in point"]        }, {          o: "outPoint",          t: ["out point"]        }, {          o: "frameRate",          t: ["frame rate"]        }, {          o: "fillColor",          t: ["fill color"]        }, {          o: "threeDLayer",          t: ["3d", "3D"]        }, {          o: "zRotation",          t: ["z rotation", "rotation z"]        }, {          o: "enabled",          t: ["visible"]        }, {          o: "timeRemapping",          t: ["time remapping"]        }, {          o: "focusDistance",          t: ["focus distance"]        }, {          o: "Point of Interest",          t: ["point of interest"]        }, {          o: "depthOfField",          t: ["depth of field"]        }, {          o: "blurLevel",          t: ["blur level"]        }, {          o: "irisShape",          t: ["iris shape"]        }, {          o: "irisRotation",          t: ["iris rotation"]        }, {          o: "irisAspectRatio",          t: ["iris aspect ratio"]        }, {          o: "irisDiffractionFringe",          t: ["iris diffraction fringe"]        }, {          o: "highlightGain",          t: ["highlight gain"]        }, {          o: "highlightThreshold",          t: ["highlight threshold"]        }, {          o: "highlightSaturation",          t: ["highlight saturation"]        }, {          o: "coneAngle",          t: ["cone angle"]        }, {          o: "coneFeather",          t: ["cone feather"]        }, {          o: "falloffDistance",          t: ["falloff distance"]        }, {          o: "castsShadows",          t: ["casts shadows"]        }, {          o: "shadowDarkness",          t: ["shadow darkness"]        }, {          o: "shadowDiffusion",          t: ["shadow diffusion"]        }, {          o: "anchorPoint",          t: ["anchor point"]        }, {          o: "fontSize",          t: ["font size"]        }, {          o: "fillColor",          t: ["fill color", "font color"]        }, {          o: "strokeColor",          t: ["stroke color"]        }, {          o: "strokeWidth",          t: ["stroke width"]        }, {          o: "strokeOverFill",          t: ["stroke over fill"]        }, {          o: "applyStroke",          t: ["apply stroke"]        }, {          o: "applyFill",          t: ["apply fill"]        }      ],      "layer.light.options": [        {          o: "lightType",          t: ["type"]        }      ],      "layer.mask": [        {          o: "mask path",          t: ["path"]        }, {          o: "maskFeather",          t: ["feather"]        }, {          o: "maskOpacity",          t: ["opacity"]        }, {          o: "maskExpansion",          t: ["expansion"]        }, {          o: "maskMode",          t: ["mode"]        }      ],      "layer.effects": [        {          o: "blending mode",          t: ["blending mode"]        }      ]    };    scope = opts.scope || "global";    translationsArray = translations[scope] || [];    if (opts.scope) {      translationsArray = translationsArray.concat(translations["global"]);    }    return toDict(translationsArray, dict);  };  return Property;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.PropertyGroup = (function(superClass) {  extend(PropertyGroup, superClass);  function PropertyGroup(data) {    this.data = data;  }  PropertyGroup.prototype.applyTo = function(object) {    return this.apply(object, this.data);  };  return PropertyGroup;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.PropertyInterpretor = (function(superClass) {  extend(PropertyInterpretor, superClass);  function PropertyInterpretor(propertyName1, propertyValue) {    var ref;    this.propertyName = propertyName1;    if (isObjectAndNotArray(propertyValue)) {      propertyValue = (ref = propertyValue.name) != null ? ref : propertyValue.id;    }    this.propertyValue = propertyValue;    PropertyInterpretor.__super__.constructor.apply(this, arguments);    this;  }  PropertyInterpretor.prototype.getPropertyName = function() {    return this.propertyName;  };  PropertyInterpretor.prototype.getPropertyValue = function() {    return this.propertyValue;  };  PropertyInterpretor.prototype.getStringifiedPropertyValue = function() {    var response;    response = this.propertyValue;    if (this.propertyValue instanceof FolderItem || this.propertyValue instanceof CompItem || this.propertyValue instanceof FootageItem || this.propertyValue instanceof Layer) {      response = this.propertyValue.name;    }    return response;  };  PropertyInterpretor.prototype.validateNotInIgnoredValues = function(ignoredValues) {    if ((ignoredValues != null ? ignoredValues[this.propertyName] : void 0) !== this.propertyValue) {      return true;    } else {      return false;    }  };  PropertyInterpretor.prototype.adapt = function(opts) {    if (opts == null) {      opts = {};    }    this.propertyName = this.adaptPropertyName(this.propertyName, opts);    this.propertyValue = this.adaptPropertyValue(this.propertyName, this.propertyValue, opts);    return this;  };  PropertyInterpretor.prototype.adaptPropertyName = function(propertyName, opts) {    var propertyNamesTranslations, ref, translatedPropertyName;    propertyNamesTranslations = this.getPropertyNameTranslations(opts, "o");    translatedPropertyName = ((ref = propertyNamesTranslations[propertyName]) != null ? ref["t"] : void 0) || propertyName;    if (translatedPropertyName instanceof Array) {      translatedPropertyName = translatedPropertyName[0];    }    return translatedPropertyName;  };  PropertyInterpretor.prototype.adaptPropertyValue = function(propertyName, propertyValue, opts) {    if (propertyValue) {      propertyValue = this.evalIfDirective(propertyValue);      propertyValue = this.makeValueReplacements(propertyName, propertyValue);    }    return propertyValue;  };  PropertyInterpretor.prototype.makeValueReplacements = function(propertyName, propertyValue, opts) {    var r;    r = propertyValue;    switch (propertyName.toLowerCase()) {      case "color":      case "color 1":      case "fillcolor":      case "color 2":      case "color 3":      case "color 4":      case "color 5":      case "map black to":      case "map white to":      case "tint color":      case "shadows unbalance":      case "midtones unbalance":      case "highlights unbalance":      case "highlights":      case "brights":      case "midtones":      case "darktones":      case "shadows":      case "color to change":        r = esy.color.rgbToHex(propertyValue);        break;      case "outpoint":      case "inpoint":      case "duration":        r = Math.round(propertyValue * 10) / 10;    }    return r;  };  return PropertyInterpretor;})(Hyle.Property);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.PropertyInstance = (function(superClass) {  extend(PropertyInstance, superClass);  function PropertyInstance(propertyName1, propertyValue1) {    this.propertyName = propertyName1;    this.propertyValue = propertyValue1;    PropertyInstance.__super__.constructor.apply(this, arguments);    this;  }  PropertyInstance.prototype.hasKeyframes = function() {    var ref;    return (ref = this.propertyValue.keyframes) != null ? ref : {      "true": false    };  };  PropertyInstance.prototype.apply = function(object, skip) {    if (skip == null) {      skip = false;    }    if (skip) {      this.setValues(object);    }    if (typeof object.property === "function") {      if (object.property(this.propertyName)) {        if (typeof object.property(this.propertyName).setValue === "function") {          this.setValues(object);        }      } else {        try {          object[this.propertyName] = this.propertyValue;        } catch (undefined) {}      }    } else {      object[this.propertyName] = this.propertyValue;    }    return this;  };  PropertyInstance.prototype.setValues = function(object) {    return PropertyInstance.__super__.setValues.call(this, object.property(this.propertyName), this.propertyValue);  };  PropertyInstance.prototype.processValue = function(propertyValue) {    return propertyValue;  };  PropertyInstance.prototype.adapt = function(opts) {    if (opts == null) {      opts = {};    }    this.propertyName = this.adaptPropertyName(this.propertyName, opts);    this.propertyValue = this.adaptPropertyValue(this.propertyName, this.propertyValue, opts);    return this;  };  PropertyInstance.prototype.adaptPropertyName = function(propertyName, opts) {    var propertyNamesTranslations, ref, translatedPropertyName;    propertyNamesTranslations = this.getPropertyNameTranslations(opts, "t");    translatedPropertyName = ((ref = propertyNamesTranslations[propertyName]) != null ? ref["o"] : void 0) || propertyName;    if (translatedPropertyName instanceof Array) {      translatedPropertyName = translatedPropertyName[0];    }    return translatedPropertyName;  };  PropertyInstance.prototype.adaptPropertyValue = function(propertyName, propertyValue, opts) {    if (propertyValue) {      propertyValue = this.evalIfDirective(propertyValue);      propertyValue = this.makeValueReplacements(propertyName, propertyValue, opts);    }    return propertyValue;  };  PropertyInstance.prototype.makeValueReplacements = function(propertyName, propertyValue, opts) {    var r;    r = propertyValue;    switch (propertyName.toLowerCase()) {      case "lighttype":        r = LightType[propertyValue.toString().toUpperCase()];        break;      case "blendingmode":        if (typeof propertyValue === "string") {          r = BlendingMode[propertyValue.replace(/( )/g, "_").toString().toUpperCase()];        }        break;      case "trackmattetype":        if (typeof propertyValue === "string") {          r = TrackMatteType[propertyValue.replace(/( )/g, "_").toString().toUpperCase()];        }        break;      case "maskmode":        if (typeof propertyValue === "string") {          r = MaskMode[propertyValue.replace(/( )/g, "_").toString().toUpperCase()];        }        break;      case "color":      case "color 1":      case "fillcolor":      case "color 2":      case "color 3":      case "color 4":      case "color 5":      case "map black to":      case "map white to":      case "tint color":      case "shadows unbalance":      case "midtones unbalance":      case "highlights unbalance":      case "highlights":      case "brights":      case "midtones":      case "darktones":      case "shadows":      case "color to change":        if (typeof propertyValue === "string") {          r = esy.color.hexToHsl(propertyValue);        }        break;      case "inPoint":      case "outPoint":      case "duration":      case "time":        r = this.convertToFrameIfNeeded(propertyValue);        break;      case "justification":        switch (propertyValue) {          case "left":          case "center":          case "right":            r = ParagraphJustification[(propertyValue.toUpperCase()) + "_JUSTIFY"];            break;          case "justifiedLeft":          case "justifiedCenter":          case "justifiedRight":            r = ParagraphJustification["FULL_JUSTIFY_LASTLINE_" + (propertyValue.replace('justified', '').toUpperCase())];        }    }    switch (opts.scope) {      case "layer.shape.contents":        switch (propertyName) {          case "type":            switch (propertyValue) {              case "rectangle":                r = "ADBE Vector Shape - Rect";                break;              case "ellipse":              case "circle":                r = "ADBE Vector Shape - Ellipse";                break;              case "polystar":                r = "ADBE Vector Shape - Star";                break;              case "fill":                r = "ADBE Vector Graphic - Fill";                break;              case "stroke":                r = "ADBE Vector Graphic - Stroke";                break;              case "gradient fill":                r = "ADBE Vector Graphic - G-Fill";                break;              case "gradient stroke":                r = "ADBE Vector Graphic - G-Stroke";                break;              case "merge paths":                r = "ADBE Vector Filter - Merge";                break;              case "offset paths":                r = "ADBE Vector Filter - Offset";                break;              case "pucker and bloat":              case "pucker & bloat":                r = "ADBE Vector Filter - PB";                break;              case "round corners":                r = "ADBE Vector Filter - RC";                break;              case "trim paths":                r = "ADBE Vector Filter - Trim";                break;              case "twist":                r = "ADBE Vector Filter - Twist";                break;              case "wiggle paths":                r = "ADBE Vector Filter - Roughen";                break;              case "wiggle transform":                r = "ADBE Vector Filter - Wiggler";                break;              case "zig zag":                r = "ADBE Vector Filter - Zigzag";                break;              case "repeater":                r = "ADBE Vector Filter - Repeater";            }        }    }    return r;  };  return PropertyInstance;})(Hyle.Property);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CompositionItem = (function(superClass) {  extend(CompositionItem, superClass);  function CompositionItem(data) {    CompositionItem.__super__.constructor.apply(this, arguments);    this.setDefaults({      label: 15,      width: 1920,      height: 1080,      pixelAspect: 1,      duration: 10,      framerate: 24,      color: [0, 0, 0]    });    this.initiate(data);    this;  }  return CompositionItem;})(Hyle.Item);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CompositionItemInterpretor = (function(superClass) {  extend(CompositionItemInterpretor, superClass);  function CompositionItemInterpretor(composition) {    this.composition = composition;    this.ignoredProperties = [];    this.data = {};    this.ignoredValues = {      parentFolder: "Root"    };    CompositionItemInterpretor.__super__.constructor.apply(this, arguments);  }  CompositionItemInterpretor.prototype.compact = function() {    this.data = CompositionItemInterpretor.__super__.compact.call(this, this.composition);    if (this.hasLayers()) {      this.interpretLayers();    }    return this.data;  };  CompositionItemInterpretor.prototype.hasLayers = function() {    if (this.composition.layers.length > 0) {      return true;    } else {      return false;    }  };  CompositionItemInterpretor.prototype.interpretLayers = function() {    var i, j, layerInterpretor, ref, results;    this.data.layers = [];    results = [];    for (i = j = 1, ref = this.composition.layers.length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      layerInterpretor = new Hyle.LayerInterpretor(this.composition.layers[i]);      results.push(this.data.layers.push(layerInterpretor.compact()));    }    return results;  };  return CompositionItemInterpretor;})(Hyle.CompositionItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CompositionItemInstance = (function(superClass) {  extend(CompositionItemInstance, superClass);  function CompositionItemInstance(data) {    this.ignoredProperties = ["parentFolder"];    CompositionItemInstance.__super__.constructor.apply(this, arguments);    this.initiate(data);  }  CompositionItemInstance.prototype.store = function() {    var base;    CompositionItemInstance.__super__.store.call(this, app.project.items.addComp(this.data.name, this.data.width, this.data.height, this.data.pixelAspect, this.data.duration, this.data.framerate));    this.item.bgColor = new Hyle.PropertyInstance("color", this.data.color).adapt().getPropertyValue();    return typeof (base = this.item).openInViewer === "function" ? base.openInViewer() : void 0;  };  CompositionItemInstance.prototype.setParentComposition = function(parentComposition) {    return parentComposition.layers.add(this.item);  };  return CompositionItemInstance;})(Hyle.CompositionItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CompositionItemsCollection = (function(superClass) {  extend(CompositionItemsCollection, superClass);  function CompositionItemsCollection() {    this.compositions = [];  }  CompositionItemsCollection.prototype.add = function(composition) {    var base;    (base = composition.item)._id || (base._id = composition.item.name);    return this.compositions[composition.item._id] = composition;  };  CompositionItemsCollection.prototype.find = function(key) {    return this.compositions[key];  };  return CompositionItemsCollection;})(Hyle.Collection);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CompositionItemsFactory = (function(superClass) {  extend(CompositionItemsFactory, superClass);  function CompositionItemsFactory(compositionsData) {    this.composition;    this.compositionItemsCollection = hyle.parser.compositionItemsCollection;    this.folderItemsCollection = hyle.parser.folderItemsCollection;    this.createCompositions(compositionsData);  }  CompositionItemsFactory.prototype.createCompositions = function(compositionsData) {    var compositionData, i, len, results;    results = [];    for (i = 0, len = compositionsData.length; i < len; i++) {      compositionData = compositionsData[i];      this.composition = new Hyle.CompositionItemInstance(compositionData);      this.composition.store();      if (compositionData.composition) {        this.setParentComposition(compositionData.composition);      }      if (compositionData.folder) {        this.setParentFolder(compositionData.folder);      }      if (compositionData.fetch) {        this.fetchComposition(compositionData.fetch);      }      if (compositionData.layers) {        this.createLayers(compositionData.layers);      }      results.push(this.compositionItemsCollection.add(this.composition));    }    return results;  };  CompositionItemsFactory.prototype.setParentComposition = function(compositionPointer) {    var parentComposition;    parentComposition = this.compositionItemsCollection.find(compositionPointer).item;    return this.composition.setParentComposition(parentComposition);  };  CompositionItemsFactory.prototype.fetchComposition = function(compositionPointer) {    var fetchedComposition;    fetchedComposition = this.compositionItemsCollection.find(compositionPointer).item;    return this.composition.item.layers.add(fetchedComposition);  };  CompositionItemsFactory.prototype.setParentFolder = function(folderPointer) {    var parentFolder;    parentFolder = this.folderItemsCollection.find(folderPointer).item;    return this.composition.setParentFolder(parentFolder);  };  CompositionItemsFactory.prototype.createLayers = function(layersData) {    var layersFactory;    return layersFactory = new Hyle.LayersFactory(layersData, this.composition);  };  return CompositionItemsFactory;})(Hyle.Factory);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileItem = (function(superClass) {  extend(FileItem, superClass);  function FileItem(data) {    FileItem.__super__.constructor.apply(this, arguments);    this.setDefaults({      label: 5,      path: ""    });    this;  }  return FileItem;})(Hyle.Item);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileItemsFactory = (function(superClass) {  extend(FileItemsFactory, superClass);  function FileItemsFactory(filesData) {    this.files = [];    this.fileItemsCollection = hyle.parser.fileItemsCollection;    this.createFiles(filesData);    this;  }  FileItemsFactory.prototype.createFiles = function(filesData) {    var fileData, i, len, results;    results = [];    for (i = 0, len = filesData.length; i < len; i++) {      fileData = filesData[i];      results.push(this.createFile(fileData));    }    return results;  };  FileItemsFactory.prototype.createFile = function(fileData) {    var file;    file = new Hyle.FileItemInstance(fileData);    file.store();    return this.fileItemsCollection.add(file);  };  return FileItemsFactory;})(Hyle.Factory);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileItemsCollection = (function(superClass) {  extend(FileItemsCollection, superClass);  function FileItemsCollection() {    this.files = [];  }  FileItemsCollection.prototype.getFileObject = function(id) {    return this.files[id];  };  FileItemsCollection.prototype.getFile = function(id) {    if (this.getFileObject(id)) {      return this.getFileObject(id).file;    } else {      return false;    }  };  FileItemsCollection.prototype.getFileOrImport = function(id) {    var file, fileData, path;    if (this.getFile(id)) {      return this.getFile(id);    } else {      path = id;      fileData = {        path: path,        name: esy.file.fileName(path)      };      file = hyle.parser.fileItemsFactory.createFile(fileData);      return file.item;    }  };  FileItemsCollection.prototype.add = function(file) {    var base;    (base = file.item)._id || (base._id = file.getFileName());    return this.files[file.item._id] = file;  };  return FileItemsCollection;})(Hyle.Collection);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileItemInstance = (function(superClass) {  extend(FileItemInstance, superClass);  function FileItemInstance(data) {    if (typeof data === "string") {      data = {        path: data      };    }    FileItemInstance.__super__.constructor.apply(this, arguments);    this.initiate(data);  }  FileItemInstance.prototype.store = function() {    var importOptions;    importOptions = new ImportOptions(File(this.data.path));    if (this.data.sequence) {      importOptions.sequence = true;    }    FileItemInstance.__super__.store.call(this, app.project.importFile(importOptions));    if (!this.data.selected) {      return this.item.selected = false;    }  };  FileItemInstance.prototype.getFileName = function() {    return esy.file.fileName(this.item.path);  };  return FileItemInstance;})(Hyle.FileItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileItemInterpretor = (function(superClass) {  extend(FileItemInterpretor, superClass);  function FileItemInterpretor(file) {    this.file = file;    this.ignoredProperties = ["items", "numItems", "typeName"];    FileItemInterpretor.__super__.constructor.apply(this, arguments);  }  FileItemInterpretor.prototype.compact = function() {    var data;    data = {};    if (this.file.parentFolder.name !== "Solids") {      data = FileItemInterpretor.__super__.compact.call(this, this.file);      data.path = this.file.mainSource.file.toString();    }    return data;  };  return FileItemInterpretor;})(Hyle.FileItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FolderItem = (function(superClass) {  extend(FolderItem, superClass);  function FolderItem(data) {    FolderItem.__super__.constructor.apply(this, arguments);    this.setDefaults({      label: 2    });    this;  }  return FolderItem;})(Hyle.Item);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FolderItemsCollection = (function(superClass) {  extend(FolderItemsCollection, superClass);  function FolderItemsCollection() {    this.folders = [];  }  FolderItemsCollection.prototype.add = function(folder) {    var base;    (base = folder.item)._id || (base._id = folder.item.name);    return this.folders[folder.item._id] = folder;  };  FolderItemsCollection.prototype.find = function(key) {    return this.folders[key];  };  return FolderItemsCollection;})(Hyle.Collection);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FolderItemInstance = (function(superClass) {  extend(FolderItemInstance, superClass);  function FolderItemInstance(data) {    this.ignoredProperties = ["parentFolder"];    FolderItemInstance.__super__.constructor.apply(this, arguments);    this.initiate(data);  }  FolderItemInstance.prototype.store = function() {    return FolderItemInstance.__super__.store.call(this, app.project.items.addFolder(this.data.name));  };  return FolderItemInstance;})(Hyle.FolderItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FolderItemsFactory = (function(superClass) {  extend(FolderItemsFactory, superClass);  function FolderItemsFactory(foldersData) {    this.folders = [];    this.foldersData = foldersData;    this.folderItemsCollection = hyle.parser.folderItemsCollection;    this.nestingLevel = 0;    this.lastStoredFolder = null;    this.currentParentFolder = app.project.rootFolder;    this.parentFoldersArray = [];    this.createFolders();    return this.folders;  }  FolderItemsFactory.prototype.createFolders = function() {    var folderData, j, len, matches, ref, results;    ref = this.foldersData;    results = [];    for (j = 0, len = ref.length; j < len; j++) {      folderData = ref[j];      if (typeof folderData === "string") {        folderData = {          name: folderData        };      }      if (folderData.name.match(/^(\| )/gi)) {        matches = folderData.name.match(/(\| )/gi);        if (matches.length > this.nestingLevel) {          this.incrementNesting(matches);        } else if (matches.length < this.nestingLevel) {          this.decrementNesting(matches);        }        folderData.name = folderData.name.replace(/^\| +/gi, "");      } else {        if (folderData.parentFolder == null) {          folderData.parentFolder = folderData.folder || folderData["parent folder"] || null;        }        if (folderData.parentFolder) {          this.currentParentFolder = this.folderItemsCollection.find(folderData.parentFolder).item;        } else {          folderData.parentFolder = this.currentParentFolder = app.project.rootFolder;        }        this.nestingLevel = 0;      }      results.push(this.lastStoredFolder = this.createFolder(folderData, this.currentParentFolder));    }    return results;  };  FolderItemsFactory.prototype.createFolder = function(data, parent) {    var folder;    folder = new Hyle.FolderItemInstance(data);    folder.store();    folder.setParentFolder(parent);    this.folderItemsCollection.add(folder);    return folder.item;  };  FolderItemsFactory.prototype.incrementNesting = function(matches) {    this.nestingLevel++;    this.currentParentFolder = this.lastStoredFolder;    return this.parentFoldersArray.push(this.lastStoredFolder);  };  FolderItemsFactory.prototype.decrementNesting = function(matches) {    var difference, i, j, ref;    difference = this.nestingLevel - matches.length;    this.nestingLevel = this.nestingLevel - difference;    for (i = j = 1, ref = difference; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      this.parentFoldersArray.pop();    }    return this.currentParentFolder = this.parentFoldersArray[this.parentFoldersArray.length - 1];  };  return FolderItemsFactory;})(Hyle.Factory);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FolderItemInterpretor = (function(superClass) {  extend(FolderItemInterpretor, superClass);  function FolderItemInterpretor(folder) {    this.folder = folder;    this.ignoredProperties = [];    this.ignoredValues = {      parentFolder: "Root"    };    FolderItemInterpretor.__super__.constructor.apply(this, arguments);  }  FolderItemInterpretor.prototype.compact = function() {    return FolderItemInterpretor.__super__.compact.call(this, this.folder);  };  return FolderItemInterpretor;})(Hyle.FolderItem);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.Layer = (function(superClass) {  extend(Layer, superClass);  function Layer() {    this.defaults = {      active: true,      adjustmentLayer: false,      audioActive: false,      audioEnabled: true,      blendingMode: 4812,      comment: "",      color: [0, 0, 0],      effectsActive: true,      elided: false,      enabled: true,      environmentLayer: false,      frameBlending: false,      frameBlendingType: 3612,      guideLayer: false,      hasAudio: false,      hasTrackMatte: false,      hasVideo: true,      height: 1080,      inPoint: 0,      label: 1,      locked: false,      motionBlur: false,      nullLayer: false,      outPoint: 100,      preserveTransparency: false,      selected: false,      shy: false,      solo: false,      startTime: 0,      stretch: 100,      threeDLayer: false,      time: 0,      timeRemapEnabled: false,      trackMatteType: 4612,      width: 1920    };  }  return Layer;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.LayerInstance = (function(superClass) {  extend(LayerInstance, superClass);  function LayerInstance() {    this.defaults = {};    this.setDefaults({      name: null,      duration: 10    });  }  LayerInstance.prototype.initiate = function(data) {    this.sourceData = clone(data);    this.layersCollection = hyle.parser.layersCollection;    return this.data = this.extend(data, this.defaults);  };  LayerInstance.prototype.setDefaults = function(defaults) {    var key, results;    results = [];    for (key in defaults) {      results.push(this.defaults[key] = defaults[key]);    }    return results;  };  LayerInstance.prototype.setPostRenderProperties = function() {    if (this.data.transform) {      this.setTransform();    }    if (this.data.effects) {      this.setEffects();    }    if (this.data.styles) {      this.setStyles();    }    if (this.data.masks) {      this.setMasks();    }    if (this.data.options) {      this.setOptions();    }    if (this.data.parent) {      return this.setParent();    }  };  LayerInstance.prototype.setParent = function() {    return this.layer.parent = hyle.parser.layersCollection.find(this.data.parent).layer;  };  LayerInstance.prototype.setTransform = function(target, data) {    if (target == null) {      target = null;    }    if (data == null) {      data = null;    }    if (!target) {      target = this.layer;    }    if (!data) {      data = this.data.transform;    }    return this.apply(target["transform"], data, true);  };  LayerInstance.prototype.setOptions = function(target, data) {    if (target == null) {      target = null;    }    if (data == null) {      data = null;    }    if (!target) {      target = this.layer;    }    if (!data) {      data = this.data.options;    }    return this.apply(target, data, true);  };  LayerInstance.prototype.setStyles = function() {    var error, i, layerStyle, len, ref, results, styleData, type;    ref = this.data.styles;    results = [];    for (i = 0, len = ref.length; i < len; i++) {      styleData = ref[i];      try {        type = styleData.type.toTitleCase();        app.executeCommand(app.findMenuCommandId(type));        layerStyle = this.layer.property("Layer Styles").property(type);        results.push(this.setStyleProperties(layerStyle, styleData));      } catch (error) {        results.push(logError("Hyle is unable find layer style named \"" + (styleData.type.toTitleCase()) + "\""));      }    }    return results;  };  LayerInstance.prototype.setStyleProperties = function(layerStyle, styleData) {    return this.apply(layerStyle, styleData, true);  };  LayerInstance.prototype.setEffects = function() {    var effectPropertiesApplier;    effectPropertiesApplier = new Hyle.EffectFactory(this.data.effects, this.layer);    return effectPropertiesApplier.applyToLayer();  };  LayerInstance.prototype.setMasks = function() {    var i, len, mask, maskData, ref, results;    ref = this.data.masks;    results = [];    for (i = 0, len = ref.length; i < len; i++) {      maskData = ref[i];      results.push(mask = new Hyle.Mask(maskData, this.layer));    }    return results;  };  LayerInstance.prototype.render = function(layer) {    this.layer = layer;    this.data = this.adaptObject(this.data, {      scope: "layer"    });    this.apply(this.layer, this.data);    return this.setPostRenderProperties();  };  return LayerInstance;})(Hyle.Layer);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.LayerInterpretor = (function(superClass) {  extend(LayerInterpretor, superClass);  function LayerInterpretor(layer) {    this.layer = layer;    this.ignoredProperties = ["nullLayer", "adjustmentLayer"];    LayerInterpretor.__super__.constructor.apply(this, arguments);  }  LayerInterpretor.prototype.compact = function() {    this.data = LayerInterpretor.__super__.compact.call(this, this.layer);    this.interpretLayerType();    if (this.hasEffects()) {      this.interpretLayerEffects();    }    return this.data;  };  LayerInterpretor.prototype.interpretLayerType = function() {    var type;    type = "";    if (this.layer.adjustmentLayer) {      type = "adjustment";    } else if (this.layer instanceof CameraLayer) {      type = "camera";    } else if (this.layer instanceof LightLayer) {      type = "light";    } else if (this.layer instanceof ShapeLayer) {      type = "shape";    } else if (this.layer instanceof TextLayer) {      type = "text";    } else if (this.layer.nullLayer) {      type = "null";    } else if (this.layer.source) {      if (this.layer.source.frameDuration < 1) {        type = "file";      } else {        type = "solid";      }    }    return this.data.type = type;  };  LayerInterpretor.prototype.hasEffects = function() {    var r;    r = false;    if (this.layer.Effects) {      if (this.layer.Effects.numProperties > 0) {        r = true;      }    }    return r;  };  LayerInterpretor.prototype.interpretLayerEffects = function() {    var effectInterpretor, i, j, ref, results;    this.data.effects = [];    results = [];    for (i = j = 1, ref = this.layer.Effects.numProperties; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      effectInterpretor = new Hyle.EffectInterpretor(this.layer.Effects.property(i));      results.push(this.data.effects.push(effectInterpretor.compact()));    }    return results;  };  return LayerInterpretor;})(Hyle.Layer);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.LayersFactory = (function(superClass) {  extend(LayersFactory, superClass);  function LayersFactory(layersData, composition) {    if (composition == null) {      composition = null;    }    this.layersData = layersData;    this.layersCollection = hyle.parser.layersCollection;    this.composition = composition;    this.createLayers();    this;  }  LayersFactory.prototype.createLayers = function() {    var i, layer, layerData, len, ref, results;    ref = this.layersData;    results = [];    for (i = 0, len = ref.length; i < len; i++) {      layerData = ref[i];      if (layerData.inherit) {        layerData = this.inherit(layerData);      }      layerData.AVCompItemTarget = this.getComposition(layerData);      layer = this.createLayer(layerData);      results.push(this.layersCollection.add(layer));    }    return results;  };  LayersFactory.prototype.createLayer = function(data) {    var layer;    data.type || (data.type = "Solid");    switch (data.type.capitalize()) {      case "Solid":        layer = new Hyle.SolidLayerInstance(data);        break;      case "Adjustment":        layer = new Hyle.AdjustmentLayerInstance(data);        break;      case "Null":        layer = new Hyle.NullLayerInstance(data);        break;      case "Light":        layer = new Hyle.LightLayerInstance(data);        break;      case "Camera":        layer = new Hyle.CameraLayerInstance(data);        break;      case "Shape":        layer = new Hyle.ShapeLayerInstance(data);        break;      case "Text":        layer = new Hyle.TextLayerInstance(data);        break;      case "File":        layer = new Hyle.FileLayerInstance(data);        break;      default:        logError("The layer type “" + data.type + "” is unknown.");    }    layer.render();    return layer;  };  LayersFactory.prototype.inherit = function(data) {    var propertyName, propertyValue, ref, target;    target = this.layersCollection.find(data.inherit);    ref = target.sourceData;    for (propertyName in ref) {      propertyValue = ref[propertyName];      if (propertyName !== "id") {        data[propertyName] || (data[propertyName] = propertyValue);      }    }    return data;  };  LayersFactory.prototype.getComposition = function(data) {    var target;    return target = (function() {      var error;      if (data.composition) {        return data.composition;      } else if (this.composition) {        return this.composition;      } else {        try {          return app.project.activeItem;        } catch (error) {          return alert("Layer " + this.name + " does not have a parent composition. Use the “composition” property to define one.");        }      }    })();  };  return LayersFactory;})(Hyle.Factory);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.LayersCollection = (function(superClass) {  extend(LayersCollection, superClass);  function LayersCollection() {    this.layers = [];  }  LayersCollection.prototype.add = function(layer) {    var base;    (base = layer.layer)._id || (base._id = layer.layer.name);    return this.layers[layer.layer._id] = layer;  };  LayersCollection.prototype.find = function(key) {    return this.layers[key];  };  return LayersCollection;})(Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.SolidLayerInstance = (function(superClass) {  extend(SolidLayerInstance, superClass);  function SolidLayerInstance(data) {    SolidLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Solid Layer",      pixelAspect: 1,      color: [0, 0, 0],      width: 1920,      height: 1080    });    this.initiate(data);    this;  }  SolidLayerInstance.prototype.initiate = function(data) {    return SolidLayerInstance.__super__.initiate.call(this, data);  };  SolidLayerInstance.prototype.render = function() {    return SolidLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addSolid(this.data.color, this.data.name, this.data.width, this.data.height, this.data.pixelAspect, this.data.duration));  };  return SolidLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.AdjustmentLayerInstance = (function(superClass) {  extend(AdjustmentLayerInstance, superClass);  function AdjustmentLayerInstance(data) {    AdjustmentLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Adjustment Layer",      adjustmentLayer: true    });    this.initiate(data);    this;  }  return AdjustmentLayerInstance;})(Hyle.SolidLayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.NullLayerInstance = (function(superClass) {  extend(NullLayerInstance, superClass);  function NullLayerInstance(data) {    NullLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Null"    });    this.initiate(data);    this;  }  NullLayerInstance.prototype.render = function() {    return NullLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addNull(this.data.duration));  };  return NullLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.LightLayerInstance = (function(superClass) {  extend(LightLayerInstance, superClass);  function LightLayerInstance(data) {    LightLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Light",      centerPoint: [0, 0]    });    this.initiate(data);    this;  }  LightLayerInstance.prototype.render = function() {    return LightLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addLight(this.data.name, this.data.centerPoint));  };  return LightLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.CameraLayerInstance = (function(superClass) {  extend(CameraLayerInstance, superClass);  function CameraLayerInstance(data) {    CameraLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Camera",      centerPoint: [0, 0]    });    this.initiate(data);    this;  }  CameraLayerInstance.prototype.render = function() {    return CameraLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addCamera(this.data.name, this.data.centerPoint));  };  return CameraLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.ShapeLayerInstance = (function(superClass) {  extend(ShapeLayerInstance, superClass);  function ShapeLayerInstance(data) {    if (data.contents == null) {      data.contents = {};    }    ShapeLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Shape Layer"    });    this.initiate(data);    this;  }  ShapeLayerInstance.prototype.render = function() {    ShapeLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addShape());    return this.setShapesProperties(this.data.contents);  };  ShapeLayerInstance.prototype.setShapesTransformProperties = function() {    return this.apply(this.layer[""], this.data.transform, true);  };  ShapeLayerInstance.prototype.setShapesProperties = function(contents, vectorGroup) {    var data, i, len, results, shape;    if (vectorGroup == null) {      vectorGroup = null;    }    results = [];    for (i = 0, len = contents.length; i < len; i++) {      data = contents[i];      switch (data.type) {        case "group":          vectorGroup = this.createShapeGroup(data);          if (data.transform) {            this.setTransform(vectorGroup, data.transform);          }          this.setShapesProperties(data.contents, vectorGroup);          break;        default:          data.type = new Hyle.PropertyInstance("type", data.type).adapt({            scope: "layer.shape.contents"          }).getPropertyValue();          vectorGroup = vectorGroup != null ? vectorGroup : vectorGroup = this.layer;          shape = vectorGroup.property("Contents").addProperty(data.type);          if (data.transform) {            this.setTransform(shape, data.transform);          }          this.apply(shape, data, true);      }      results.push(vectorGroup = null);    }    return results;  };  ShapeLayerInstance.prototype.createShapeGroup = function(groupData) {    var vectorGroup;    vectorGroup = this.layer.property("Contents").addProperty("ADBE Vector Group");    if (groupData != null ? groupData.name : void 0) {      vectorGroup.name = groupData.name;    }    return vectorGroup;  };  return ShapeLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.TextLayerInstance = (function(superClass) {  extend(TextLayerInstance, superClass);  function TextLayerInstance(data) {    TextLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      name: "Text Layer",      text: "",      fontSize: 72,      fillColor: [1, 1, 1],      strokeColor: [0, 0, 0],      strokeWidth: 0,      font: "Helvetica",      strokeOverFill: false,      applyStroke: false,      applyFill: true,      justification: "center",      tracking: 0    });    this.initiate(data);    this;  }  TextLayerInstance.prototype.initiate = function(data) {    this.hasName = data.name != null;    return TextLayerInstance.__super__.initiate.call(this, data);  };  TextLayerInstance.prototype.render = function() {    var textDocument;    textDocument = new Hyle.TextDocument(this.data);    TextLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.addText(textDocument.getValue()));    if (!this.hasName) {      this.layer.name = textDocument.getValue();    }    textDocument.setLayer(this.layer);    return textDocument.setTextDocument();  };  return TextLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.FileLayerInstance = (function(superClass) {  extend(FileLayerInstance, superClass);  function FileLayerInstance(data) {    this.file = {};    FileLayerInstance.__super__.constructor.apply(this, arguments);    this.setDefaults({      label: 5    });    this.initiate(data);    this;  }  FileLayerInstance.prototype.render = function() {    this.file = hyle.parser.fileItemsCollection.getFileOrImport(this.data.file);    return FileLayerInstance.__super__.render.call(this, this.data.AVCompItemTarget.layers.add(this.file));  };  return FileLayerInstance;})(Hyle.LayerInstance);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.Mask = (function(superClass) {  extend(Mask, superClass);  function Mask(data, layer) {    var mask;    mask = this.setMask(data, layer);    return mask;  }  Mask.prototype.setMask = function(maskData, AVLayer) {    var mask, myShape, propertyName, propertyValue;    maskData = this.adaptObject(maskData, {      scope: "layer.mask"    });    mask = AVLayer.Masks.addProperty("Mask");    if (mask.name) {      mask.name = maskData.name;    }    for (propertyName in maskData) {      propertyValue = maskData[propertyName];      switch (propertyName) {        case "mask path":          myShape = this.setMaskShape(propertyValue);          myShape.closed = maskData.closed || (maskData.closed = true);          mask.property("ADBE Mask Shape").setValue(myShape);          break;        case "maskMode":        case "inverted":        case "rotoBezier":        case "maskMotionBlur":        case "locked":        case "color":        case "maskFeatherFalloff":          mask[propertyName] = propertyValue;      }    }    return this.apply(mask, maskData);  };  Mask.prototype.setMaskShape = function(maskPathData) {    var shape, tangents, verticesArray;    shape = new Shape();    verticesArray = [];    if (isObjectAndNotArray(maskPathData)) {      verticesArray = this.setMaskShapeVertices(maskPathData);      tangents = this.setMaskShapeVerticesTangents(maskPathData);    } else {      verticesArray = maskPathData.path != null ? maskPathData.path : maskPathData.path = verticesData;      tangents = {        inTangents: maskPathData.inTangents != null ? maskPathData.inTangents : maskPathData.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0]],        outTangents: maskPathData.outTangents != null ? maskPathData.outTangents : maskPathData.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0]]      };    }    shape.vertices = verticesArray;    shape.inTangents = tangents.inTangents;    shape.outTangents = tangents.outTangents;    return shape;  };  Mask.prototype.setMaskShapeVertices = function(maskPathData) {    var height, verticesArray, width, x, y;    verticesArray = [];    x = maskPathData.position[0];    y = maskPathData.position[1];    width = maskPathData.width;    height = maskPathData.height;    if (maskPathData.type === "rectangle") {      verticesArray.push([x, y]);      verticesArray.push([x + width, y]);      verticesArray.push([x + width, y + height]);      verticesArray.push([x, y + height]);    }    if (maskPathData.type === "ellipse") {      verticesArray.push([x + width / 2, y]);      verticesArray.push([x + width, y + height / 2]);      verticesArray.push([x + width / 2, y + height]);      verticesArray.push([x, y + height / 2]);    }    return verticesArray;  };  Mask.prototype.setMaskShapeVerticesTangents = function(maskPathData) {    var heightTangent, inTangents, outTangents, tangents, widthTangent;    if (maskPathData.type === "ellipse") {      widthTangent = maskPathData.width * 2 * (Math.sqrt(2) - 1) / 3;      heightTangent = maskPathData.height * 2 * (Math.sqrt(2) - 1) / 3;      inTangents = [[-widthTangent, 0], [0, -heightTangent], [widthTangent, 0], [0, heightTangent]];      outTangents = [[widthTangent, 0], [0, heightTangent], [-widthTangent, 0], [0, -heightTangent]];    } else {      outTangents = inTangents = [[0, 0], [0, 0], [0, 0], [0, 0]];    }    tangents = {      inTangents: inTangents,      outTangents: outTangents    };    return tangents;  };  return Mask;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectPropertyGroup = (function(superClass) {  extend(EffectPropertyGroup, superClass);  function EffectPropertyGroup(data) {    this.data = data;  }  EffectPropertyGroup.prototype.applyTo = function(object) {    return EffectPropertyGroup.__super__.applyTo.call(this, object);  };  EffectPropertyGroup.prototype.adapt = function() {    var property, propertyName, propertyValue, ref;    ref = this.data;    for (propertyName in ref) {      propertyValue = ref[propertyName];      property = new Hyle.PropertyInstance(propertyName, propertyValue);      property.adapt({        scope: "layer.effects"      });      delete this.data[propertyName];      if (propertyName === "blending mode") {        log((property.getPropertyName()) + " = " + (property.getPropertyValue()));      }      this.data[property.getPropertyName().toTitleCase()] = property.getPropertyValue();    }    return this;  };  return EffectPropertyGroup;})(Hyle.PropertyGroup);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.Effect = (function(superClass) {  extend(Effect, superClass);  function Effect() {    this.defaults = {      active: true,      enabled: true,      name: "Effect"    };  }  return Effect;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectFactory = (function(superClass) {  extend(EffectFactory, superClass);  function EffectFactory(data, layer) {    this.data = data;    this.layer = layer;  }  EffectFactory.prototype.applyToLayer = function() {    var effect, effectData, i, len, ref, results;    ref = this.data;    results = [];    for (i = 0, len = ref.length; i < len; i++) {      effectData = ref[i];      results.push(effect = new Hyle.EffectInstance(effectData, this.layer));    }    return results;  };  return EffectFactory;})(Hyle.Factory);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectInstance = (function(superClass) {  extend(EffectInstance, superClass);  function EffectInstance(data, layer) {    this.data = data;    this.layer = layer;    this.effect = {};    this.render();  }  EffectInstance.prototype.render = function() {    var e, error;    try {      this.effect = this.layer.Effects.addProperty(this.data.type.capitalize());    } catch (error) {      e = error;      alert("Hyle is unable find effect named \"" + (this.data.type.capitalize()) + "\"");    }    if (this.data.name) {      this.effect.name = this.data.name;    }    return this.setEffectProperties();  };  EffectInstance.prototype.setEffectProperties = function() {    var propertyGroup;    propertyGroup = new Hyle.EffectPropertyGroup(this.data.properties);    return propertyGroup.adapt().applyTo(this.effect);  };  return EffectInstance;})(Hyle.Effect);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectInterpretor = (function(superClass) {  extend(EffectInterpretor, superClass);  function EffectInterpretor(effect) {    this.effect = effect;    this.ignoredProperties = ["active", "canSetEnabled", "enabled", "isEffect", "isModified", "matchName", "numProperties", "parentProperty", "propertyDepth", "propertyIndex", "propertyType"];    this.data = {};    EffectInterpretor.__super__.constructor.apply(this, arguments);  }  EffectInterpretor.prototype.compact = function() {    this.data = EffectInterpretor.__super__.compact.call(this, this.effect, {      bypassDefaults: true    });    if (this.hasEffectProperties()) {      this.interpretEffectProperties();    }    return this.data;  };  EffectInterpretor.prototype.hasEffectProperties = function() {    return this.effect.numProperties > 0;  };  EffectInterpretor.prototype.interpretEffectProperties = function() {    var effectPropertyInterpretor, i, j, propertyInterpreted, ref, results;    this.data.properties = [];    results = [];    for (i = j = 1, ref = this.effect.numProperties; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {      effectPropertyInterpretor = new Hyle.EffectPropertyInterpretor(this.effect.property(i));      propertyInterpreted = effectPropertyInterpretor.compact();      if (propertyInterpreted) {        results.push(this.data.properties.push(propertyInterpreted));      } else {        results.push(void 0);      }    }    return results;  };  return EffectInterpretor;})(Hyle.Effect);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectProperty = (function(superClass) {  extend(EffectProperty, superClass);  function EffectProperty() {    return EffectProperty.__super__.constructor.apply(this, arguments);  }  return EffectProperty;})(Hyle.Object);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.EffectPropertyInterpretor = (function(superClass) {  extend(EffectPropertyInterpretor, superClass);  function EffectPropertyInterpretor(effectProperty) {    this.effectProperty = effectProperty;    this.ignoredProperties = ["active", "canSetExpression", "canVaryOverTime", "enabled", "expressionEnabled", "hasMax", "hasMin", "isTimeVarying", "isSpatial", "isModified", "matchName", "maxValue", "minValue", "numProperties", "numKeys", "parentProperty", "propertyDepth", "propertyIndex", "propertyType", "propertyValueType", "selectedKeys", "unitsText"];    this.ignoredItems = {      matchName: "ADBE Effect Built In Params"    };    this.data = {};    EffectPropertyInterpretor.__super__.constructor.apply(this, arguments);  }  EffectPropertyInterpretor.prototype.compact = function() {    if (this.effectProperty.isModified) {      return this.data = EffectPropertyInterpretor.__super__.compact.call(this, this.effectProperty, {        bypassDefaults: true      });    } else {      return false;    }  };  return EffectPropertyInterpretor;})(Hyle.EffectProperty);// Generated by CoffeeScript 1.10.0var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },  hasProp = {}.hasOwnProperty;Hyle.TextDocument = (function(superClass) {  extend(TextDocument, superClass);  function TextDocument(data) {    this.data = data;    this.layer = null;    this.setValue();  }  TextDocument.prototype.setTextDocument = function() {    var sourceText, textDocument;    sourceText = this.layer.property("Source Text");    textDocument = {};    textDocument = this.setTextDocumentProperty(sourceText);    return this.setValues(sourceText, textDocument);    /*    Know bug here: The textDocument doesn't apply when there are keyframes    The code below should be a good starting point but doesn't work.        if @data.sourceText.keyframes      textDocument.keyframes = []      for keyframe in @data.sourceText.keyframes        textDocument.keyframes.push          time: keyframe.time          value: @setTextDocumentProperty sourceText     */  };  TextDocument.prototype.setTextDocumentProperty = function(sourceText) {    var i, len, propertyName, ref, textDocument;    textDocument = sourceText.value;    textDocument.resetCharStyle();    ref = ["fontSize", "fillColor", "strokeWidth", "font", "strokeOverFill", "applyStroke", "applyFill", "justification", "tracking"];    for (i = 0, len = ref.length; i < len; i++) {      propertyName = ref[i];      textDocument[propertyName] = this.data[propertyName];    }    return textDocument;  };  TextDocument.prototype.setValues = function(sourceText, textDocument) {    return TextDocument.__super__.setValues.call(this, sourceText, textDocument);  };  TextDocument.prototype.setLayer = function(layer) {    return this.layer = layer;  };  TextDocument.prototype.getValue = function() {    return this.value;  };  TextDocument.prototype.setValue = function() {    if (typeof this.data === "string") {      return this.value = this.data;    } else if (this.data.value) {      return this.value = this.data.value;    } else {      return this.value = "";    }  };  TextDocument.prototype.getTextDocumentSourceText = function() {};  return TextDocument;})(Hyle.Property);hyle.container = this;hyle.initialize();