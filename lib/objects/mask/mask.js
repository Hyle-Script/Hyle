// Generated by CoffeeScript 1.7.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Hyle.Mask = (function(_super) {
  __extends(Mask, _super);

  function Mask(data, layer) {
    var mask;
    mask = this.setMask(data, layer);
    return mask;
  }

  Mask.prototype.setMask = function(maskData, AVLayer) {
    var mask, myShape, propertyName, propertyValue;
    maskData = this.adaptObject(maskData, {
      scope: "layer.mask"
    });
    mask = AVLayer.Masks.addProperty("Mask");
    if (mask.name) {
      mask.name = maskData.name;
    }
    for (propertyName in maskData) {
      propertyValue = maskData[propertyName];
      switch (propertyName) {
        case "mask path":
          myShape = this.setMaskShape(propertyValue);
          myShape.closed = maskData.closed || (maskData.closed = true);
          mask.property("ADBE Mask Shape").setValue(myShape);
          break;
        case "maskMode":
        case "inverted":
        case "rotoBezier":
        case "maskMotionBlur":
        case "locked":
        case "color":
        case "maskFeatherFalloff":
          mask[propertyName] = propertyValue;
      }
    }
    return this.apply(mask, maskData);
  };

  Mask.prototype.setMaskShape = function(maskPathData) {
    var shape, tangents, verticesArray;
    shape = new Shape();
    verticesArray = [];
    if (isObjectAndNotArray(maskPathData)) {
      verticesArray = this.setMaskShapeVertices(maskPathData);
      tangents = this.setMaskShapeVerticesTangents(maskPathData);
    } else {
      verticesArray = maskPathData.path != null ? maskPathData.path : maskPathData.path = verticesData;
      tangents = {
        inTangents: maskPathData.inTangents != null ? maskPathData.inTangents : maskPathData.inTangents = [[0, 0], [0, 0], [0, 0], [0, 0]],
        outTangents: maskPathData.outTangents != null ? maskPathData.outTangents : maskPathData.outTangents = [[0, 0], [0, 0], [0, 0], [0, 0]]
      };
    }
    shape.vertices = verticesArray;
    shape.inTangents = tangents.inTangents;
    shape.outTangents = tangents.outTangents;
    return shape;
  };

  Mask.prototype.setMaskShapeVertices = function(maskPathData) {
    var height, verticesArray, width, x, y;
    verticesArray = [];
    x = maskPathData.position[0];
    y = maskPathData.position[1];
    width = maskPathData.width;
    height = maskPathData.height;
    if (maskPathData.type === "rectangle") {
      verticesArray.push([x, y]);
      verticesArray.push([x + width, y]);
      verticesArray.push([x + width, y + height]);
      verticesArray.push([x, y + height]);
    }
    if (maskPathData.type === "ellipse") {
      verticesArray.push([x + width / 2, y]);
      verticesArray.push([x + width, y + height / 2]);
      verticesArray.push([x + width / 2, y + height]);
      verticesArray.push([x, y + height / 2]);
    }
    return verticesArray;
  };

  Mask.prototype.setMaskShapeVerticesTangents = function(maskPathData) {
    var heightTangent, inTangents, outTangents, tangents, widthTangent;
    if (maskPathData.type === "ellipse") {
      widthTangent = maskPathData.width * 2 * (Math.sqrt(2) - 1) / 3;
      heightTangent = maskPathData.height * 2 * (Math.sqrt(2) - 1) / 3;
      inTangents = [[-widthTangent, 0], [0, -heightTangent], [widthTangent, 0], [0, heightTangent]];
      outTangents = [[widthTangent, 0], [0, heightTangent], [-widthTangent, 0], [0, -heightTangent]];
    } else {
      outTangents = inTangents = [[0, 0], [0, 0], [0, 0], [0, 0]];
    }
    tangents = {
      inTangents: inTangents,
      outTangents: outTangents
    };
    return tangents;
  };

  return Mask;

})(Hyle.Object);
